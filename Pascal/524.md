# Euler Problem 524 Solution in Pascal

Let me solve Euler Problem 524 step by step.

Euler Problem 524 asks for the number of permutations of the digits 1,2,3,4,5,6,7,8,9 that are "divisible by 9" (meaning the sum of digits is divisible by 9), but more specifically, it's asking for the number of permutations where the sum of digits is divisible by 9, and the permutation itself satisfies certain conditions.

Actually, let me re-read the problem more carefully. Euler Problem 524 is about finding the number of permutations of 1,2,3,4,5,6,7,8,9 such that when you read them as numbers, they are divisible by 9.

Wait, that's not right either. Let me check what the actual problem is...

Actually, Euler Problem 524 is: Find the number of permutations of the digits 1,2,3,4,5,6,7,8,9 such that the sum of the first k digits is divisible by k for all k from 1 to 9.

Let me solve this properly:

```pascal
program Euler524;
{$APPTYPE CONSOLE}

var
  digits: array[1..9] of integer;
  used: array[1..9] of boolean;
  count: int64;
  i: integer;

function isDivisibleByK(prefixSum, k: integer): boolean;
begin
  isDivisibleByK := (prefixSum mod k = 0);
end;

procedure backtrack(pos: integer);
var
  i, sum: integer;
begin
  if pos > 9 then
  begin
    // We've formed a complete permutation
    inc(count);
    exit;
  end;
  
  // Try each unused digit
  for i := 1 to 9 do
  begin
    if not used[i] then
    begin
      // Add this digit to our permutation
      used[i] := true;
      digits[pos] := i;
      
      // Calculate prefix sum
      sum := 0;
      for var j := 1 to pos do
        sum := sum + digits[j];
      
      // Check if prefix sum is divisible by position
      if isDivisibleByK(sum, pos) then
        backtrack(pos + 1);
      
      // Backtrack
      used[i] := false;
    end;
  end;
end;

begin
  // Initialize
  for i := 1 to 9 do
    used[i] := false;
  count := 0;
  
  // Start backtracking
  backtrack(1);
  
  writeln('Answer: ', count);
end.
```

However, let me reconsider this more carefully. The problem is asking for permutations where each prefix is divisible by its position. Let me write a more optimized version:

```pascal
program Euler524;
{$APPTYPE CONSOLE}

var
  used: array[1..9] of boolean;
  digits: array[1..9] of integer;
  count: int64;

procedure generate(pos: integer; prefixSum: integer);
var
  i: integer;
begin
  if pos > 9 then
  begin
    inc(count);
    exit;
  end;
  
  // For position pos, prefixSum must be divisible by pos
  if (prefixSum mod pos) <> 0 then
    exit;
  
  // Try placing each unused digit
  for i := 1 to 9 do
  begin
    if not used[i] then
    begin
      used[i] := true;
      digits[pos] := i;
      generate(pos + 1, prefixSum + i);
      used[i] := false;
    end;
  end;
end;

begin
  count := 0;
  for i := 1 to 9 do
    used[i] := false;
  
  generate(1, 0);
  
  writeln('The answer is: ', count);
end.
```

Actually, let me think about this more systematically. The constraint is that for each position k, the sum of the first k digits must be divisible by k.

Let me trace through the constraints:
- Position 1: sum of first 1 digit must be divisible by 1 (always true)
- Position 2: sum of first 2 digits must be divisible by 2
- Position 3: sum of first 3 digits must be divisible by 3
- And so on...

```pascal
program Euler524;
{$APPTYPE CONSOLE}

var
  used: array[1..9] of boolean;
  digits: array[1..9] of integer;
  count: int64;

procedure backtrack(pos: integer; currentSum: integer);
var
  i: integer;
begin
  // If we've placed all 9 digits
  if pos > 9 then
  begin
    inc(count);
    exit;
  end;
  
  // Check if current prefix sum is divisible by position
  if (currentSum mod pos) <> 0 then
    exit;
  
  // Try placing each unused digit
  for i := 1 to 9 do
  begin
    if not used[i] then
    begin
      used[i] := true;
      backtrack(pos + 1, currentSum + i);
      used[i] := false;
    end;
  end;
end;

begin
  count := 0;
  for i := 1 to 9 do
    used[i] := false;
  
  backtrack(1, 0);
  
  writeln('Answer: ', count);
end.
```

