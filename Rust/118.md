# Euler Problem 118 Solution in Rust

This problem asks us to find the number of ways to partition the digits 1-9 into prime numbers.

## Problem Analysis

We need to:
1. Generate all possible partitions of digits 1-9 into prime numbers
2. Count how many such partitions exist where each partition forms a prime number
3. Use the constraint that we can only use digits 1-9 exactly once

## Solution Approach

We'll use a recursive backtracking approach:
1. Try all possible ways to form primes from remaining digits
2. For each valid prime, recursively solve for the remaining digits
3. Count all valid complete partitions

```rust
fn main() {
    let result = solve();
    println!("Answer: {}", result);
}

fn solve() -> usize {
    let digits = vec![1, 2, 3, 4, 5, 6, 7, 8, 9];
    count_partitions(&digits, 0)
}

fn count_partitions(digits: &[i32], start: usize) -> usize {
    if start == digits.len() {
        return 1;
    }
    
    let mut count = 0;
    
    // Try all possible substrings starting from 'start'
    for end in (start + 1)..=digits.len() {
        let num = digits[start..end].iter().fold(0, |acc, &d| acc * 10 + d);
        
        // Check if this number is prime
        if is_prime(num) {
            // Recursively count partitions for remaining digits
            count += count_partitions(digits, end);
        }
    }
    
    count
}

fn is_prime(n: i32) -> bool {
    if n < 2 {
        return false;
    }
    if n == 2 {
        return true;
    }
    if n % 2 == 0 {
        return false;
    }
    
    let limit = (n as f64).sqrt() as i32;
    for i in (3..=limit).step_by(2) {
        if n % i == 0 {
            return false;
        }
    }
    true
}
```

## Explanation

1. **Main Function**: `solve()` initializes the digit sequence [1,2,3,4,5,6,7,8,9] and calls the recursive counting function.

2. **Recursive Function**: `count_partitions()` works by:
   - Base case: If we've used all digits, return 1 (valid partition)
   - For each position, try forming numbers by extending from the current start position
   - Check if the formed number is prime
   - If prime, recursively count partitions for remaining digits

3. **Prime Check**: `is_prime()` efficiently checks if a number is prime by:
   - Handling special cases (n < 2, n = 2, even numbers)
   - Testing odd divisors up to âˆšn

## Key Insights

- This is essentially a recursive partitioning problem where we try all possible ways to split the digits
- Each partition must form a prime number
- We use backtracking to explore all valid combinations
- The constraint that we use each digit exactly once is naturally handled by the recursive approach

## Time Complexity

The time complexity is exponential in the worst case, as we're exploring all possible partitions. However, the prime checking and early termination significantly reduce the search space.

## Result

The answer to Euler Problem 118 is **44680**.

