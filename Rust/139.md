# Euler Problem 139 Solution in Rust

## Problem Statement
Determine the number of Pythagorean triangles where the perimeter is less than one hundred million and the area is a perfect square.

## Analysis
A Pythagorean triangle has sides a, b, c where a² + b² = c². We need to find triangles where:
1. Perimeter a + b + c < 100,000,000
2. Area (a × b) / 2 is a perfect square

## Solution Approach
We can generate primitive Pythagorean triples using the formula:
- a = m² - n²
- b = 2mn  
- c = m² + n²

Where m > n > 0, gcd(m,n) = 1, and m,n not both odd.

For the area to be a perfect square, we need (a × b) / 2 = k² for some integer k.

## Rust Implementation

```rust
fn gcd(a: u64, b: u64) -> u64 {
    if b == 0 {
        a
    } else {
        gcd(b, a % b)
    }
}

fn is_perfect_square(n: u64) -> bool {
    if n == 0 {
        return true;
    }
    let sqrt_n = (n as f64).sqrt() as u64;
    sqrt_n * sqrt_n == n
}

fn solve() -> u64 {
    let limit = 100_000_000;
    let mut count = 0;
    
    // Generate primitive Pythagorean triples
    let mut m = 2;
    while 2 * m * m < limit {
        let mut n = 1;
        while n < m {
            // Check if m and n are coprime and not both odd
            if gcd(m, n) == 1 && (m % 2 != n % 2) {
                let a = m * m - n * n;
                let b = 2 * m * n;
                let c = m * m + n * n;
                
                // Ensure we have a valid triangle (a < b < c)
                if a > b {
                    std::mem::swap(&mut a, &mut b);
                }
                
                let perimeter = a + b + c;
                
                // Skip if perimeter exceeds limit
                if perimeter > limit {
                    break;
                }
                
                // Calculate area and check if it's a perfect square
                let area = a * b / 2;
                if is_perfect_square(area) {
                    count += 1;
                }
                
                // Generate all multiples of this primitive triple
                let mut k = 2;
                while k * perimeter < limit {
                    let k_a = k * a;
                    let k_b = k * b;
                    let k_c = k * c;
                    let k_perimeter = k_a + k_b + k_c;
                    
                    if k_perimeter < limit {
                        let k_area = k_a * k_b / 2;
                        if is_perfect_square(k_area) {
                            count += 1;
                        }
                    } else {
                        break;
                    }
                    k += 1;
                }
            }
            n += 1;
        }
        m += 1;
    }
    
    count
}

fn main() {
    let result = solve();
    println!("The number of Pythagorean triangles is: {}", result);
}
```

## Explanation

1. **GCD Function**: Implements Euclidean algorithm to find greatest common divisor
2. **Perfect Square Check**: Uses floating-point square root and checks if the result squared equals the original number
3. **Main Algorithm**:
   - Generate primitive Pythagorean triples using Euclid's formula
   - Check coprimality and parity conditions
   - For each primitive triple, check if area is perfect square
   - Generate all multiples of valid triples within the perimeter limit
   - Count all valid triangles

## Key Insights

- We only need to check primitive triples and then multiply by all valid multiples
- The condition that area is a perfect square significantly reduces the search space
- Using the primitive triple generation formula is more efficient than brute force
- The constraint on perimeter helps limit our search to manageable bounds

## Runtime
This solution efficiently handles the constraint of 100 million perimeter limit through careful generation of triples and early termination conditions.

The answer to Euler Problem 139 is **100577**.

