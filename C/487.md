# Euler Problem 487 Solution in C

I'll solve Euler Problem 487, which asks for the sum of the last 10 digits of the sum of all numbers n where 1 ≤ n ≤ 10^10 and n is divisible by 5.

## Problem Understanding

The problem asks for: 
- Sum of all numbers n where 1 ≤ n ≤ 10^10 and n is divisible by 5
- Find the last 10 digits of this sum

## Approach

Since we're dealing with 10^10 numbers, we can't iterate through all of them. Instead, we can use mathematical formulas:

1. The sum of all multiples of 5 from 1 to 10^10 is: 5 × (1 + 2 + 3 + ... + (10^10/5))
2. This equals: 5 × (10^10/5) × (10^10/5 + 1) / 2
3. Simplifying: (10^10) × (10^10 + 5) / 10
4. Which equals: (10^10) × (10^10 + 5) / 10 = 10^19 + 5 × 10^9

Let me implement this in C:

```c
#include <stdio.h>
#include <stdint.h>

int main() {
    // Calculate sum of all multiples of 5 from 1 to 10^10
    // This equals 5 * (1 + 2 + 3 + ... + 2*10^9)
    // = 5 * (2*10^9) * (2*10^9 + 1) / 2
    // = 5 * 10^9 * (2*10^9 + 1)
    // = 5 * 10^9 * 2*10^9 + 5 * 10^9
    // = 10^19 + 5 * 10^9
    
    // Using modular arithmetic to get last 10 digits
    const uint64_t MOD = 10000000000ULL; // 10^10
    
    // Calculate 10^19 mod 10^10 = 0
    // Calculate 5 * 10^9 mod 10^10 = 5000000000
    uint64_t result = (0 + 5000000000ULL) % MOD;
    
    printf("Last 10 digits: %llu\n", result);
    
    // Let me verify with a more detailed approach
    // Sum = 5 * (1 + 2 + ... + 20000000000)
    // Sum = 5 * 20000000000 * 20000000001 / 2
    // Sum = 5 * 10000000000 * 20000000001
    // Sum = 50000000000 * 20000000001
    
    // Actually, let's do it properly:
    uint64_t n = 10000000000ULL;  // 10^10
    uint64_t count = n / 5;       // Number of multiples of 5
    
    // Sum = 5 * (1 + 2 + ... + count)
    // Sum = 5 * count * (count + 1) / 2
    
    // To avoid overflow, we'll compute this carefully
    uint64_t sum = 0;
    
    // Since count = 2 * 10^9, we need to be careful
    uint64_t count_half = count / 2;
    
    if (count % 2 == 0) {
        // count is even
        sum = 5 * count_half % MOD * count % MOD;
    } else {
        // count is odd
        sum = 5 * count % MOD * (count + 1) / 2 % MOD;
    }
    
    // Let's use the direct mathematical approach:
    // Sum = 5 * (1 + 2 + ... + 2*10^9) = 5 * 2*10^9 * (2*10^9 + 1) / 2
    // = 5 * 10^9 * (2*10^9 + 1) = 5 * 10^9 * 2*10^9 + 5 * 10^9
    // = 10^19 + 5 * 10^9
    
    uint64_t term1 = 0;  // 10^19 mod 10^10 = 0
    uint64_t term2 = 5000000000ULL;  // 5 * 10^9
    
    uint64_t final_result = (term1 + term2) % MOD;
    
    printf("The last 10 digits of the sum are: %llu\n", final_result);
    
    return 0;
}
```

Wait, let me reconsider this more carefully and provide a cleaner solution:

```c
#include <stdio.h>
#include <stdint.h>

int main() {
    // Euler Problem 487
    // We want the last 10 digits of the sum of all multiples of 5 from 1 to 10^10
    
    const uint64_t MOD = 10000000000ULL; // 10^10
    
    // Number of multiples of 5 from 1 to 10^10
    uint64_t n = 10000000000ULL;
    uint64_t count = n / 5;  // 2 * 10^9
    
    // Sum of multiples of 5 from 1 to 10^10
    // = 5 * (1 + 2 + 3 + ... + count)
    // = 5 * count * (count + 1) / 2
    
    // We need to compute this mod 10^10
    
    // Since count = 20000000000, let's be careful with modular arithmetic
    uint64_t sum = 0;
    
    // Method 1: Direct calculation with modular arithmetic
    // sum = 5 * count * (count + 1) / 2 mod 10^10
    
    // Let's compute this step by step:
    uint64_t c = count % MOD;
    uint64_t c_plus_1 = (count + 1) % MOD;
    
    // We need to compute (5 * c * (c + 1) / 2) mod MOD
    // But since we're dealing with very large numbers, let's think differently
    
    // Actually, count = 2 * 10^9
    // So we want 5 * (2 * 10^9) * (2 * 10^9 + 1) / 2 mod 10^10
    // = 5 * 10^9 * (2 * 10^9 + 1) mod 10^10
    // = 5 * 10^9 * 2 * 10^9 + 5 * 10^9 mod 10^10
    // = 10^19 + 5 * 10^9 mod 10^10
    
    // Since 10^19 mod 10^10 = 0, we get 0 + 5 * 10^9 mod 10^10 = 5 * 10^9
    
    uint64_t result = (5 * 10000000000ULL) % MOD;
    
    printf("The last 10 digits of the sum are: %llu\n", result);
    
    return 0;
}
```

Let me provide the final clean solution:

```c
#include <stdio.h>
#include <stdint.h>

int main() {
    // Euler Problem 487
    // Find the last 10 digits of sum of all multiples of 5 from 1 to 10^10
    
    const uint64_t MOD = 10000000000ULL; // 10^10
    
    // The sum of multiples of 5 from 1 to 10^10:
    // = 5 * (1 + 2 + 3 + ... + 2*10^9)
    // = 5 * (2*10^9) * (2*10^9 + 1) / 2
    // = 5 * 10^9 * (2*10^9 + 1)
    // = 5 * 10^9 * 2*10^9 + 5 * 10^9
    // = 10^19 + 5 * 10^9
    
    // Taking modulo 10^10:
    // 10^19 mod 10^10 = 0
    // 5 * 10^9 mod 10^10 = 5000000000
    
    uint64_t result = 5000000000ULL;
    
    printf("The last 10 digits of the sum are: %llu\n", result);
    
    return 0;
}
```

## Final Answer

The last 10 digits of the sum of all numbers from 1 to 10^10 that are divisible by 5 is **5000000000**.

