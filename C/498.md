# Euler Problem 498 Solution in C

I'll solve Euler Problem 498, which asks for the number of ways to write n as a sum of positive integers, where the order doesn't matter (partitions of n).

```c
#include <stdio.h>
#include <stdlib.h>

// Function to compute the number of partitions of n
// Using dynamic programming with the recurrence relation
// p(n,k) = p(n,k-1) + p(n-k,k) where p(n,k) is number of partitions of n into parts <= k
long long partition(int n) {
    // Create a 2D array to store partition values
    long long **p = (long long**)malloc((n + 1) * sizeof(long long*));
    for (int i = 0; i <= n; i++) {
        p[i] = (long long*)calloc((n + 1), sizeof(long long));
    }
    
    // Base cases
    for (int i = 0; i <= n; i++) {
        p[0][i] = 1;  // One way to partition 0 (empty partition)
    }
    
    // Fill the table using recurrence relation
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            if (i < j) {
                p[i][j] = p[i][j-1];
            } else {
                p[i][j] = (p[i][j-1] + p[i-j][j]) % 1000000007;
            }
        }
    }
    
    long long result = p[n][n];
    
    // Free memory
    for (int i = 0; i <= n; i++) {
        free(p[i]);
    }
    free(p);
    
    return result;
}

// Alternative approach using Euler's pentagonal number theorem
// For better efficiency with large numbers
long long partition_optimized(int n) {
    if (n < 0) return 0;
    if (n == 0) return 1;
    
    // Use memoization
    static long long *memo = NULL;
    static int memo_size = 0;
    
    if (memo_size <= n) {
        memo = (long long*)realloc(memo, (n + 1) * sizeof(long long));
        for (int i = memo_size; i <= n; i++) {
            memo[i] = 0;
        }
        memo_size = n + 1;
    }
    
    if (memo[n] != 0) return memo[n];
    
    long long result = 0;
    int k = 1;
    int sign = 1;
    
    // Using Euler's pentagonal number theorem
    while (1) {
        // Pentagonal numbers: k(3k-1)/2 and k(3k+1)/2
        long long pent1 = k * (3 * k - 1) / 2;
        long long pent2 = k * (3 * k + 1) / 2;
        
        if (pent1 > n) break;
        
        if (pent1 <= n) {
            result = (result + sign * partition_optimized(n - pent1)) % 1000000007;
        }
        if (pent2 <= n) {
            result = (result + sign * partition_optimized(n - pent2)) % 1000000007;
        }
        
        k++;
        sign = -sign;
    }
    
    memo[n] = result;
    return result;
}

int main() {
    // For Euler Problem 498, we need to find the number of partitions of 10^12
    // Since 10^12 is too large for direct computation, we'll use the optimized approach
    // But for demonstration, let's compute a smaller case
    
    printf("Computing partitions for small numbers:\n");
    for (int i = 0; i <= 10; i++) {
        printf("p(%d) = %lld\n", i, partition_optimized(i));
    }
    
    // For the actual problem with n = 10^12, we would need a more sophisticated approach
    // The direct computation would be too slow, so we'd use mathematical properties
    
    printf("\nFor the actual problem (n = 10^12), the approach would use:\n");
    printf("1. Mathematical properties of partition functions\n");
    printf("2. Modular arithmetic\n");
    printf("3. Efficient computation using generating functions\n");
    printf("4. The result would be computed modulo 1000000007\n");
    
    // Since computing p(10^12) directly is computationally infeasible with basic approaches,
    // here's a demonstration with a manageable case
    printf("\nDemonstration with n = 1000:\n");
    long long result = partition_optimized(1000);
    printf("p(1000) mod 1000000007 = %lld\n", result);
    
    return 0;
}
```

## Explanation

Euler Problem 498 asks for the number of partitions of a large number (specifically 10^12) modulo 1000000007.

### Key Concepts:

1. **Partition Function**: The number of ways to write a positive integer n as a sum of positive integers, disregarding order.

2. **Mathematical Approach**: 
   - Direct computation using dynamic programming is inefficient for large numbers
   - The solution uses Euler's pentagonal number theorem for efficient computation
   - Modular arithmetic is used to handle large numbers

3. **Algorithm**:
   - Uses memoization to avoid recomputation
   - Applies Euler's pentagonal number theorem: p(n) = Σ(-1)^(k+1) × p(n - g_k) where g_k are pentagonal numbers
   - Computes everything modulo 1000000007

### Time Complexity:
- The optimized approach using Euler's formula is much more efficient than naive dynamic programming
- For large n like 10^12, mathematical properties and modular arithmetic are essential

### Note:
For the actual value of p(10^12) mod 1000000007, a more advanced mathematical approach using generating functions and modular arithmetic would be required, which goes beyond what can be easily computed with basic C code. The implementation above shows the structure and approach for solving such problems.

