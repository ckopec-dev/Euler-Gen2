# Euler Problem 644 Solution in C

I'll solve Euler Problem 644, which asks for the number of ways to write a number as a sum of powers of 2, where each power can be used at most twice.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Function to calculate the number of ways to write n as sum of powers of 2
// where each power can be used at most twice
long long count_ways(int n) {
    // dp[i][j] represents number of ways to make sum i using powers of 2
    // up to 2^j, where each power can be used at most twice
    long long dp[1000001][20]; // Assuming n <= 1000000 and 2^20 > 1000000
    
    // Initialize dp array
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j < 20; j++) {
            dp[i][j] = 0;
        }
    }
    
    // Base case: one way to make sum 0 (use nothing)
    dp[0][0] = 1;
    
    // For each power of 2
    for (int j = 0; j < 20; j++) {
        long long power = 1LL << j; // 2^j
        
        // If power > n, no need to consider further
        if (power > n) break;
        
        // For each possible sum
        for (int i = 0; i <= n; i++) {
            // Don't use this power
            dp[i][j+1] += dp[i][j];
            
            // Use this power once
            if (i + power <= n) {
                dp[i + power][j+1] += dp[i][j];
            }
            
            // Use this power twice
            if (i + 2 * power <= n) {
                dp[i + 2 * power][j+1] += dp[i][j];
            }
        }
    }
    
    return dp[n][20];
}

// Optimized approach using dynamic programming with better space complexity
long long solve_euler_644(int n) {
    // dp[i] = number of ways to make sum i
    long long dp[1000001] = {0};
    dp[0] = 1; // One way to make 0 (use nothing)
    
    // For each power of 2 from 1 to 2^k where 2^k <= n
    for (int power = 1; power <= n; power *= 2) {
        // Process from right to left to avoid using updated values
        for (int i = n; i >= 0; i--) {
            // We can use 0, 1, or 2 copies of current power
            if (i >= power) {
                dp[i] += dp[i - power];
            }
            if (i >= 2 * power) {
                dp[i] += dp[i - 2 * power];
            }
        }
    }
    
    return dp[n];
}

int main() {
    // Calculate for n = 10^6 as per the problem
    int n = 1000000;
    long long result = solve_euler_644(n);
    
    printf("Euler Problem 644 - Number of ways to write %d as sum of powers of 2\n", n);
    printf("where each power can be used at most twice: %lld\n", result);
    
    // Test with smaller values for verification
    printf("\nVerification with smaller values:\n");
    printf("n=1: %lld ways\n", solve_euler_644(1));
    printf("n=2: %lld ways\n", solve_euler_644(2));
    printf("n=3: %lld ways\n", solve_euler_644(3));
    printf("n=4: %lld ways\n", solve_euler_644(4));
    
    return 0;
}
```

## Explanation

This solution implements a dynamic programming approach to count the number of ways to express a number as a sum of powers of 2, where each power can be used at most twice.

### Key Insights:
1. **Dynamic Programming State**: `dp[i]` represents the number of ways to make sum `i`
2. **Transition**: For each power of 2, we can use 0, 1, or 2 copies of it
3. **Optimization**: We process powers from smallest to largest and update from right to left to avoid using updated values

### Algorithm Steps:
1. Initialize `dp[0] = 1` (one way to make 0)
2. For each power of 2 (1, 2, 4, 8, ...):
   - For each sum from right to left:
     - Add ways to make current sum using 0 copies of current power
     - Add ways to make current sum using 1 copy of current power  
     - Add ways to make current sum using 2 copies of current power
3. Return `dp[n]` as the answer

### Time and Space Complexity:
- **Time Complexity**: O(n log n) where n is the input number
- **Space Complexity**: O(n)

The solution handles the large constraint of n = 10^6 efficiently using dynamic programming with proper optimization to avoid recomputation.

