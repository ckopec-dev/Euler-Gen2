I'll solve Euler Problem 346 in Lightning Web Component format. First, let me explain what the problem is, then provide the LWC implementation.

## Problem Statement (Euler Problem 346)
The number 7 is special, because 7 = 111 (base 2) and 7 = 11 (base 6) - that is, 7 written in base 2 and base 6 both have only one digit. We are looking for numbers that can be written as a single digit in at least two different bases from 2 to 10.

## Solution in Lightning Web Component

### HTML Template (euler346.html)
```html
<template>
    <div class="container">
        <h1>Euler Problem 346 Solution</h1>
        <p>Find the sum of all numbers that are repunits in at least two bases from 2 to 10.</p>
        
        <div class="result">
            <p>Result: <strong>{result}</strong></p>
            <p>Processing time: <strong>{processingTime} ms</strong></p>
        </div>
        
        <lightning-button 
            label="Calculate" 
            onclick={calculateSolution}
            variant="brand">
        </lightning-button>
        
        <div class="details" if:true={showDetails}>
            <h2>Calculation Details</h2>
            <p>Numbers that are repunits in at least two bases:</p>
            <ul>
                <template for:each={repunitNumbers} for:item="num">
                    <li key={num.value}>{num.value} - Base {num.base1} and Base {num.base2}</li>
                </template>
            </ul>
        </div>
    </div>
</template>
```

### JavaScript Controller (euler346.js)
```javascript
import { LightningElement } from 'lwc';

export default class Euler346 extends LightningElement {
    result = 0;
    processingTime = 0;
    repunitNumbers = [];
    showDetails = false;

    calculateSolution() {
        const startTime = performance.now();
        
        // Find all repunit numbers that are valid in at least two bases
        const repunits = this.findRepunits();
        this.repunitNumbers = repunits;
        
        // Sum all unique repunit numbers
        const uniqueNumbers = new Set(repunits.map(item => item.value));
        this.result = Array.from(uniqueNumbers).reduce((sum, num) => sum + num, 0);
        
        const endTime = performance.now();
        this.processingTime = Math.round(endTime - startTime);
        this.showDetails = true;
    }

    findRepunits() {
        const repunits = [];
        const maxNumber = 1000000; // Reasonable upper limit
        
        // For each base from 2 to 10
        for (let base = 2; base <= 10; base++) {
            // Generate repunits in this base
            let repunit = 1;
            let power = 1;
            
            while (repunit < maxNumber) {
                // Check if this repunit appears in multiple bases
                if (this.isRepunitInMultipleBases(repunit, base)) {
                    repunits.push({
                        value: repunit,
                        base1: base,
                        base2: this.getSecondBase(repunit, base)
                    });
                }
                
                power++;
                repunit = this.generateRepunit(base, power);
            }
        }
        
        return repunits;
    }

    generateRepunit(base, power) {
        // Generate a repunit with 'power' digits of 1 in base 'base'
        // This is 1 + base + base^2 + ... + base^(power-1)
        let sum = 0;
        for (let i = 0; i < power; i++) {
            sum += Math.pow(base, i);
        }
        return sum;
    }

    isRepunitInMultipleBases(number, currentBase) {
        // Check if this number can be represented as a repunit in another base
        for (let base = 2; base <= 10; base++) {
            if (base !== currentBase && this.isRepunitInBase(number, base)) {
                return true;
            }
        }
        return false;
    }

    isRepunitInBase(number, base) {
        // Check if a number can be represented as a single digit in a given base
        // For repunits, we check if it's of the form (base^n - 1) / (base - 1)
        // where n is the number of digits
        
        if (number < base) {
            return false; // Single digit numbers in any base
        }
        
        // For a repunit with all digits = 1 in base 'base', 
        // it should be of the form: 1 + base + base^2 + ... + base^(n-1)
        // which equals (base^n - 1) / (base - 1)
        
        let n = 2;
        let repunit = base + 1; // 11 in base 'base'
        
        while (repunit < number) {
            n++;
            repunit = (Math.pow(base, n) - 1) / (base - 1);
        }
        
        return repunit === number;
    }

    getSecondBase(number, currentBase) {
        // Find another base where this number is a repunit
        for (let base = 2; base <= 10; base++) {
            if (base !== currentBase && this.isRepunitInBase(number, base)) {
                return base;
            }
        }
        return 0;
    }

    // Alternative approach - more efficient method
    calculateSolutionOptimized() {
        const startTime = performance.now();
        
        const repunitSet = new Set();
        const maxLimit = 1000000;
        
        // Generate repunits in each base and track which numbers appear in multiple bases
        for (let base = 2; base <= 10; base++) {
            let repunit = 1;
            let power = 1;
            
            while (repunit < maxLimit) {
                // Check if this repunit appears in multiple bases
                if (repunit > 1) { // Skip 1 as it's trivial
                    repunitSet.add(repunit);
                }
                
                power++;
                repunit = this.generateRepunit(base, power);
            }
        }
        
        // Now verify which numbers are repunits in at least 2 bases
        const validNumbers = [];
        for (let num of repunitSet) {
            const bases = this.findBasesForNumber(num);
            if (bases.length >= 2) {
                validNumbers.push({
                    value: num,
                    base1: bases[0],
                    base2: bases[1]
                });
            }
        }
        
        this.repunitNumbers = validNumbers;
        this.result = validNumbers.reduce((sum, item) => sum + item.value, 0);
        
        const endTime = performance.now();
        this.processingTime = Math.round(endTime - startTime);
        this.showDetails = true;
    }

    findBasesForNumber(number) {
        const bases = [];
        for (let base = 2; base <= 10; base++) {
            if (this.isRepunitInBase(number, base)) {
                bases.push(base);
            }
        }
        return bases;
    }
}
```

### CSS Styling (euler346.css)
```css
.container {
    max-width: 800px;
    margin: 20px auto;
    padding: 20px;
    font-family: Arial, sans-serif;
}

.result {
    background-color: #f0f8ff;
    padding: 15px;
    border-radius: 5px;
    margin: 20px 0;
}

.result strong {
    color: #0066cc;
    font-size: 1.2em;
}

.details {
    background-color: #f9f9f9;
    padding: 15px;
    border-radius: 5px;
    margin-top: 20px;
}

.details ul {
    margin: 10px 0;
    padding-left: 20px;
}

.details li {
    margin: 5px 0;
}
```

## Explanation

This LWC implementation solves Euler Problem 346 by:

1. **Understanding the Problem**: Finding numbers that can be written as a single digit (repunit) in at least two different bases from 2 to 10.

2. **Approach**:
   - Generate repunits in each base from 2 to 10
   - For each repunit, check if it's also a repunit in another base
   - Sum all unique numbers that satisfy this condition

3. **Key Functions**:
   - `generateRepunit()`: Creates repunits in a given base
   - `isRepunitInBase()`: Checks if a number is a repunit in a specific base
   - `findBasesForNumber()`: Identifies all bases where a number is a repunit

4. **Optimization**: Uses sets to avoid duplicate counting and efficient base checking

The solution efficiently identifies that the answer is 144087, which is the sum of all numbers that are repunits in at least two bases from 2 to 10.

