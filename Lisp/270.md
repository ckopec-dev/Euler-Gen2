# Euler Problem 270 Solution in Lisp

I'll solve Euler Problem 270, which asks for the number of ways to tile a 3×n rectangle with 2×1 dominoes.

## Problem Understanding

We need to find the number of ways to tile a 3×n rectangle using 2×1 dominoes. This is a classic dynamic programming problem.

## Approach

I'll use dynamic programming with states representing different configurations of the bottom row:
- State 0: All positions filled
- State 1: Bottom-left position filled, others empty
- State 2: Bottom-right position filled, others empty  
- State 3: Middle position filled, others empty

## Solution

```lisp
(defun euler-270 (n)
  "Calculate number of ways to tile a 3×n rectangle with 2×1 dominoes"
  (if (<= n 0)
      0
      (let ((dp (make-array 4 :initial-element 0)))
        ;; Base cases
        (setf (aref dp 0) 1)  ; 3×0 rectangle - 1 way (empty)
        (setf (aref dp 1) 0)  ; 3×1 rectangle - 0 ways (impossible)
        (setf (aref dp 2) 0)  ; 3×1 rectangle - 0 ways (impossible)
        (setf (aref dp 3) 0)  ; 3×1 rectangle - 0 ways (impossible)
        
        ;; For n = 1, we can't fill anything with 2×1 dominoes
        ;; For n = 2, we can fill with 3 horizontal dominoes
        (if (>= n 2)
            (let ((dp2 (make-array 4 :initial-element 0)))
              (setf (aref dp2 0) 3)  ; 3×2 rectangle - 3 ways
              (setf (aref dp2 1) 0)
              (setf (aref dp2 2) 0)
              (setf (aref dp2 3) 0)
              (setf dp dp2)))
        
        ;; For larger n, use recurrence relations
        (loop for i from 3 to n do
              (let ((new-dp (make-array 4 :initial-element 0)))
                ;; State 0: all filled - can be reached from:
                ;; - 3 horizontal dominoes from state 0
                ;; - 2 horizontal dominoes + 1 vertical domino from state 3
                ;; - 1 horizontal domino + 2 vertical dominoes from state 1 or 2
                (setf (aref new-dp 0) (+ (aref dp 0) (aref dp 3)))
                
                ;; State 1: bottom-left filled
                (setf (aref new-dp 1) (+ (aref dp 0) (aref dp 2)))
                
                ;; State 2: bottom-right filled
                (setf (aref new-dp 2) (+ (aref dp 0) (aref dp 1)))
                
                ;; State 3: middle filled
                (setf (aref new-dp 3) (aref dp 0))
                
                (setf dp new-dp)))
        
        (aref dp 0))))

;; More efficient version using matrix exponentiation
(defun euler-270-fast (n)
  "Fast calculation using matrix exponentiation"
  (if (<= n 0)
      0
      (if (= n 1)
          0
          (if (= n 2)
              3
              (let ((base-matrix (make-array '(4 4) :initial-element 0)))
                ;; Set up transition matrix
                (setf (aref base-matrix 0 0) 1)
                (setf (aref base-matrix 0 3) 1)
                (setf (aref base-matrix 1 0) 1)
                (setf (aref base-matrix 1 2) 1)
                (setf (aref base-matrix 2 0) 1)
                (setf (aref base-matrix 2 1) 1)
                (setf (aref base-matrix 3 0) 1)
                
                ;; Matrix exponentiation
                (let ((result (matrix-power base-matrix (- n 2))))
                  (let ((initial (vector 3 0 0 0)))
                    (aref (matrix-vector-multiply result initial) 0))))))))

(defun matrix-power (matrix n)
  "Calculate matrix^n using fast exponentiation"
  (if (= n 0)
      (identity-matrix (array-dimension matrix 0))
      (if (= n 1)
          matrix
          (let ((half (matrix-power matrix (floor n 2))))
            (if (evenp n)
                (matrix-multiply half half)
                (matrix-multiply (matrix-multiply half half) matrix))))))

(defun identity-matrix (n)
  "Create n×n identity matrix"
  (let ((result (make-array '(n n) :initial-element 0)))
    (loop for i from 0 below n do
          (setf (aref result i i) 1))
    result))

(defun matrix-multiply (a b)
  "Multiply two matrices"
  (let ((rows (array-dimension a 0))
        (cols (array-dimension b 1))
        (k (array-dimension b 0))
        (result (make-array '(rows cols) :initial-element 0)))
    (loop for i from 0 below rows do
          (loop for j from 0 below cols do
                (loop for l from 0 below k do
                      (incf (aref result i j) 
                            (* (aref a i l) (aref b l j))))))
    result))

(defun matrix-vector-multiply (matrix vector)
  "Multiply matrix by vector"
  (let ((rows (array-dimension matrix 0))
        (result (make-array rows :initial-element 0)))
    (loop for i from 0 below rows do
          (loop for j from 0 below (array-dimension vector 0) do
                (incf (aref result i) 
                      (* (aref matrix i j) (aref vector j)))))
    result))

;; Simpler iterative solution
(defun euler-270-simple (n)
  "Simple iterative solution for Euler 270"
  (if (<= n 0)
      0
      (if (= n 1)
          0
          (if (= n 2)
              3
              (let ((a 0) (b 0) (c 3) (d 0))
                (loop for i from 3 to n do
                      (let ((new-a c) (new-b (+ a c)) (new-c (+ a b)) (new-d a))
                        (setf a new-a b new-b c new-c d new-d)))
                c)))))

;; Final clean solution
(defun solve-euler-270 (n)
  "Solve Euler Problem 270: Number of ways to tile 3×n rectangle with 2×1 dominoes"
  (cond
    ((<= n 0) 0)
    ((= n 1) 0)
    ((= n 2) 3)
    (t (let ((dp (make-array 4 :initial-element 0)))
         (setf (aref dp 0) 3) ; 3×2 case
         (loop for i from 3 to n do
               (let ((new-a (aref dp 0))
                     (new-b (+ (aref dp 0) (aref dp 2)))
                     (new-c (+ (aref dp 0) (aref dp 1)))
                     (new-d (aref dp 0)))
                 (setf (aref dp 0) new-a
                       (aref dp 1) new-b
                       (aref dp 2) new-c
                       (aref dp 3) new-d)))
         (aref dp 0)))))

;; Test the solution
(defun test-euler-270 ()
  (format t "Euler 270 results:~%")
  (format t "n=1: ~A~%" (solve-euler-270 1))
  (format t "n=2: ~A~%" (solve-euler-270 2))
  (format t "n=3: ~A~%" (solve-euler-270 3))
  (format t "n=4: ~A~%" (solve-euler-270 4))
  (format t "n=5: ~A~%" (solve-euler-270 5))
  (format t "n=10: ~A~%" (solve-euler-270 10)))

;; Run the test
(test-euler-270)
```

## Explanation

The solution uses dynamic programming with four states representing different configurations of the bottom row of the 3×n rectangle:

1. **State 0**: All positions filled
2. **State 1**: Bottom-left position filled, others empty  
3. **State 2**: Bottom-right position filled, others empty
4. **State 3**: Middle position filled, others empty

The recurrence relations are:
- `dp[0] = dp[0] + dp[3]` (can be reached from state 0 or 3)
- `dp[1] = dp[0] + dp[2]` (can be reached from state 0 or 2)
- `dp[2] = dp[0] + dp[1]` (can be reached from state 0 or 1)  
- `dp[3] = dp[0]` (can be reached from state 0)

The final answer is stored in `dp[0]`, which represents the number of ways to tile a 3×n rectangle.

## Time and Space Complexity

- **Time Complexity**: O(n)
- **Space Complexity**: O(1) for the optimized version

The solution efficiently calculates the number of domino tilings for any given n.

