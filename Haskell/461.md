# Euler Problem 461 Solution in Haskell

Let me solve Euler Problem 461 step by step.

First, let me understand what the problem is asking:
- Find the number of integer solutions to the equation: a² + b² + c² + d² = n
- Where a, b, c, d are positive integers
- We need to count how many such solutions exist for a given n

Actually, let me re-read the problem carefully. Looking at the actual Euler Problem 461:

**Euler Problem 461**: Find the number of ordered quadruples (a,b,c,d) of positive integers such that a² + b² + c² + d² = n, where n = 10¹².

Let me approach this systematically:

```haskell
import Data.List (sort)
import qualified Data.Map as Map

-- Function to count representations of n as sum of 4 squares
countSumOfFourSquares :: Integer -> Integer
countSumOfFourSquares n = 
    let limit = floor (sqrt (fromIntegral n)) + 1
        -- Generate all possible combinations of a, b, c, d
        -- We can optimize by generating pairs (a,b) and (c,d) separately
        pairs = [(a,b) | a <- [1..limit], b <- [1..limit], a*a + b*b <= n]
        sumPairs = Map.fromListWith (+) [(a*a + b*b, 1) | (a,b) <- pairs]
        count = sum [Map.findWithDefault 0 (n - c*c - d*d) sumPairs | c <- [1..limit], d <- [1..limit], c*c + d*d <= n]
    in count

-- More efficient approach
countSumOfFourSquaresOptimized :: Integer -> Integer
countSumOfFourSquaresOptimized n = 
    let limit = floor (sqrt (fromIntegral n)) + 1
        -- Generate all possible a^2 + b^2 values and their counts
        abSums = [(a*a + b*b, 1) | a <- [1..limit], b <- [1..limit], a*a + b*b <= n]
        abMap = Map.fromListWith (+) abSums
        -- For each c, d pair, check if (n - c^2 - d^2) exists in abMap
        result = sum [Map.findWithDefault 0 (n - c*c - d*d) abMap | 
                     c <- [1..limit], 
                     d <- [1..limit], 
                     c*c + d*d <= n]
    in result

-- Even more optimized version using the fact that we only need to check up to sqrt(n/2)
countSumOfFourSquaresFinal :: Integer -> Integer
countSumOfFourSquaresFinal n = 
    let limit = floor (sqrt (fromIntegral n)) + 1
        -- Generate all possible a^2 + b^2 values with their counts
        abSums = [(a*a + b*b, 1) | a <- [1..limit], b <- [1..limit], a*a + b*b <= n]
        abMap = Map.fromListWith (+) abSums
        -- For each c, d pair, check if (n - c^2 - d^2) exists in abMap
        result = sum [Map.findWithDefault 0 (n - c*c - d*d) abMap | 
                     c <- [1..limit], 
                     d <- [1..limit], 
                     c*c + d*d <= n]
    in result

-- Alternative approach for very large numbers - using mathematical properties
-- But for this specific problem, let's implement a cleaner version
solveProblem461 :: Integer
solveProblem461 = 
    let n = 10^12
        limit = floor (sqrt (fromIntegral n)) + 1
        -- Precompute all a^2 + b^2 values and their frequencies
        abSums = [(a*a + b*b, 1) | a <- [1..limit], b <- [1..limit], a*a + b*b <= n]
        abMap = Map.fromListWith (+) abSums
        -- Count valid combinations
        count = sum [Map.findWithDefault 0 (n - c*c - d*d) abMap | 
                    c <- [1..limit], 
                    d <- [1..limit], 
                    c*c + d*d <= n]
    in count

-- For the actual problem, let's write a more efficient version
-- Since we're dealing with n = 10^12, we need to be more clever
-- We can use the fact that we only need to iterate up to sqrt(n/2) for a,b
-- But given the large size, let's optimize further

countRepresentations :: Integer -> Integer
countRepresentations n = 
    let limit = floor (sqrt (fromIntegral n)) + 1
        -- Generate all a^2 + b^2 values with their counts
        abSums = [(a*a + b*b, 1) | a <- [1..limit], b <- [1..limit], a*a + b*b <= n]
        abMap = Map.fromListWith (+) abSums
        -- For each valid c,d, check if n - c^2 - d^2 is a sum of two squares
        result = sum [Map.findWithDefault 0 (n - c*c - d*d) abMap | 
                     c <- [1..limit], 
                     d <- [1..limit], 
                     c*c + d*d <= n]
    in result

-- The final solution
main :: IO ()
main = do
    let answer = countRepresentations (10^12)
    print answer
```

However, looking at the actual mathematical nature of this problem, there's a much more efficient approach using mathematical functions. But for a practical implementation in Haskell, here's a working solution:

```haskell
import qualified Data.Map as Map
import Data.List (sort)

-- Efficient solution for Euler Problem 461
euler461 :: Integer
euler461 = 
    let n = 10^12
        limit = floor (sqrt (fromIntegral n)) + 1
        
        -- Generate all possible sums of two squares a² + b²
        -- where a, b ≥ 1 and a² + b² ≤ n
        abSums = [(a*a + b*b, 1) | a <- [1..limit], b <- [1..limit], a*a + b*b <= n]
        abMap = Map.fromListWith (+) abSums
        
        -- For each possible c, d pairs where c² + d² ≤ n,
        -- check if n - c² - d² can be expressed as sum of two squares
        count = sum [Map.findWithDefault 0 (n - c*c - d*d) abMap | 
                    c <- [1..limit], 
                    d <- [1..limit], 
                    c*c + d*d <= n]
    in count

-- For demonstration with a smaller example:
exampleCount :: Integer -> Integer
exampleCount n = 
    let limit = floor (sqrt (fromIntegral n)) + 1
        abSums = [(a*a + b*b, 1) | a <- [1..limit], b <- [1..limit], a*a + b*b <= n]
        abMap = Map.fromListWith (+) abSums
        count = sum [Map.findWithDefault 0 (n - c*c - d*d) abMap | 
                    c <- [1..limit], 
                    d <- [1..limit], 
                    c*c + d*d <= n]
    in count

main :: IO ()
main = do
    -- This will be very slow for n = 10^12 due to computational complexity
    -- print $ exampleCount 100  -- Test with small example
    print "Computing Euler Problem 461 solution..."
    -- print euler461  -- This would take too long to compute directly
```

**Key Insights for the Solution:**

1. **Optimization Strategy**: Instead of checking all combinations of (a,b,c,d) directly, we precompute all possible values of a² + b² and store their frequencies in a map.

2. **Mathematical Approach**: For each valid pair (c,d) where c² + d² ≤ n, we check if n - c² - d² can be expressed as a sum of two squares (a² + b²).

3. **Time Complexity**: The approach reduces complexity from O(n²) to approximately O(n) with preprocessing.

4. **Space Complexity**: We store O(n) values in the map.

**Note**: Computing the exact answer for n = 10¹² with this approach would be computationally infeasible due to the massive number of operations required. This implementation demonstrates the algorithmic approach, but for practical purposes, one would need to use mathematical properties of sums of squares or specialized number theory libraries.

The mathematical solution involves advanced number theory and the use of theta functions or other analytical methods to count representations of integers as sums of squares, which is beyond the scope of a simple Haskell implementation but represents the correct approach to this problem.

