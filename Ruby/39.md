# Euler Problem 39 Solution in Ruby

## Problem Statement
If p is the perimeter of a right angle triangle with integral length sides, {a,b,c}, there are exactly three solutions for p = 120:
{20,48,52}, {24,45,51}, {30,40,50}

For which value of p ≤ 1000, is the number of solutions maximized?

## Solution

```ruby
def count_solutions(perimeter)
  count = 0
  # For a right triangle with sides a, b, c where a + b + c = p
  # and a² + b² = c², we have c = p - a - b
  # So a² + b² = (p - a - b)²
  
  # We can iterate through possible values of a and b
  # Since a ≤ b ≤ c and a + b + c = p, we have a ≤ p/3
  (1..perimeter/3).each do |a|
    # Using the constraint that a ≤ b and b ≤ c
    # From a + b + c = p and a² + b² = c²
    # We get b = (p² - 2pa) / (2(p-a))
    
    numerator = perimeter * perimeter - 2 * perimeter * a
    denominator = 2 * (perimeter - a)
    
    # Skip if b is not an integer
    next if numerator % denominator != 0
    
    b = numerator / denominator
    c = perimeter - a - b
    
    # Check if this forms a valid right triangle
    # and if a ≤ b ≤ c
    if a <= b && b <= c && a * a + b * b == c * c
      count += 1
    end
  end
  
  count
end

# Find the perimeter with maximum solutions
max_solutions = 0
best_perimeter = 0

(1..1000).each do |p|
  solutions = count_solutions(p)
  if solutions > max_solutions
    max_solutions = solutions
    best_perimeter = p
  end
end

puts "Perimeter with maximum solutions: #{best_perimeter}"
puts "Number of solutions: #{max_solutions}"
```

## Alternative Approach (More Efficient)

```ruby
def count_solutions_optimized(perimeter)
  count = 0
  
  # For a right triangle with integer sides a ≤ b ≤ c
  # We know a + b + c = p and a² + b² = c²
  # So a + b + √(a² + b²) = p
  # This gives us: √(a² + b²) = p - a - b
  # Squaring both sides: a² + b² = (p - a - b)²
  
  (1..perimeter/3).each do |a|
    # Solve for b: a² + b² = (p - a - b)²
    # a² + b² = p² + a² + b² - 2pa - 2pb + 2ab
    # 0 = p² - 2pa - 2pb + 2ab
    # 2pb - 2ab = p² - 2pa
    # b(2p - 2a) = p² - 2pa
    # b = (p² - 2pa) / (2p - 2a) = p(p - 2a) / (2(p - a))
    
    numerator = perimeter * (perimeter - 2 * a)
    denominator = 2 * (perimeter - a)
    
    next if denominator == 0 || numerator % denominator != 0
    
    b = numerator / denominator
    c = perimeter - a - b
    
    # Verify that this is a valid solution
    if a <= b && b <= c && a * a + b * b == c * c
      count += 1
    end
  end
  
  count
end

# Find the optimal perimeter
max_solutions = 0
best_perimeter = 0

(1..1000).each do |p|
  solutions = count_solutions_optimized(p)
  if solutions > max_solutions
    max_solutions = solutions
    best_perimeter = p
  end
end

puts "Answer: #{best_perimeter}"
puts "Maximum solutions: #{max_solutions}"
```

## Output
```
Answer: 840
Maximum solutions: 8
```

## Explanation

The solution works by:

1. For each perimeter value p from 1 to 1000, we count how many valid right triangles exist
2. For a right triangle with sides a, b, c where a ≤ b ≤ c and a + b + c = p:
   - We use the constraint that a² + b² = c²
   - Since c = p - a - b, we substitute to get: a² + b² = (p - a - b)²
   - Solving for b in terms of a and p gives us a formula to compute b directly
3. We iterate through possible values of a and check if the resulting b is an integer and forms a valid triangle
4. We keep track of the perimeter that gives the maximum number of solutions

The answer is **840**, which has 8 different solutions for right triangles with integer sides.

