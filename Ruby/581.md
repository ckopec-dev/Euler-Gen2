# Euler Problem 581 Solution in Ruby

Let me solve this step by step.

First, let me understand what Euler Problem 581 asks for:
- Find the sum of all numbers n where n ≤ 10^10
- For which the number of divisors of n is exactly 2014
- The number of divisors function d(n) counts how many positive divisors n has

## Mathematical Analysis

The number of divisors function d(n) for a number n = p₁^a₁ × p₂^a₂ × ... × pₖ^aₖ is:
d(n) = (a₁ + 1)(a₂ + 1)...(aₖ + 1)

We need d(n) = 2014.

First, let's find the prime factorization of 2014:
2014 = 2 × 1007 = 2 × 19 × 53

So we need to find all ways to express 2014 as a product of integers ≥ 2, which will give us the possible forms of n.

## Approach

1. Find all possible factorizations of 2014 into factors ≥ 2
2. For each factorization, determine the corresponding form of n
3. Generate all valid n ≤ 10^10
4. Sum them up

Let me implement this in Ruby:

```ruby
def prime_factors(n)
  factors = []
  d = 2
  while d * d <= n
    while n % d == 0
      factors << d
      n /= d
    end
    d += 1
  end
  factors << n if n > 1
  factors
end

def divisors(n)
  divs = []
  (1..Math.sqrt(n)).each do |i|
    if n % i == 0
      divs << i
      divs << n / i unless i == n / i
    end
  end
  divs.sort
end

def num_divisors(n)
  return 1 if n == 1
  factors = prime_factors(n)
  factor_counts = Hash.new(0)
  factors.each { |f| factor_counts[f] += 1 }
  
  result = 1
  factor_counts.each do |_, count|
    result *= (count + 1)
  end
  result
end

def get_divisor_partitions(n)
  # Get all ways to write n as product of integers >= 2
  partitions = []
  
  def backtrack(target, min_factor, current_partition, partitions)
    if target == 1
      partitions << current_partition.dup if current_partition.length > 0
      return
    end
    
    (min_factor..target).each do |i|
      if target % i == 0
        current_partition << i
        backtrack(target / i, i, current_partition, partitions)
        current_partition.pop
      end
    end
  end
  
  backtrack(n, 2, [], partitions)
  partitions
end

def generate_numbers_from_partition(partition, max_n)
  # Generate numbers with given divisor partition
  # partition = [a1, a2, ..., ak] where d(n) = (a1+1)(a2+1)...(ak+1) = n
  # So we want n = p1^a1 * p2^a2 * ... * pk^ak where p1 < p2 < ... < pk
  
  numbers = []
  primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]
  
  # This is a complex combinatorial problem
  # For now, let's take a different approach
  
  # Generate all possible combinations
  # We'll use a recursive approach to generate numbers
  return [] if partition.empty?
  
  # For simplicity, let's use a more direct approach
  # We know that if d(n) = 2014 = 2 × 19 × 53, then
  # n can have the form where the exponents + 1 multiply to 2014
  
  # All possible combinations of exponents:
  # 2014 = 2014 (one prime to power 2013)
  # 2014 = 2 × 1007 (two primes to power 1 and 1006)
  # 2014 = 19 × 106 (two primes to power 18 and 105)
  # 2014 = 53 × 38 (two primes to power 52 and 37)
  # 2014 = 2 × 19 × 53 (three primes to power 1, 18, and 52)
  
  # But let's be more systematic:
  # 2014 = 2 × 19 × 53
  # So we can have:
  # - n = p^2013 (exponent 2013)
  # - n = p^1006 × q^1 (exponent 1006 and 1)
  # - n = p^105 × q^18 (exponent 105 and 18)
  # - n = p^37 × q^52 (exponent 37 and 52)
  # - n = p^1 × q^18 × r^52 (exponent 1, 18, and 52)
  # - n = p^1 × q^52 × r^18 (exponent 1, 52, and 18)
  # - n = p^18 × q^1 × r^52 (exponent 18, 1, and 52)
  # - n = p^18 × q^52 × r^1 (exponent 18, 52, and 1)
  # - n = p^52 × q^1 × r^18 (exponent 52, 1, and 18)
  # - n = p^52 × q^18 × r^1 (exponent 52, 18, and 1)
  
  # Actually, let me reconsider the problem more systematically.
  # The key insight is that we need to find all possible ways to write 2014
  # as a product of integers, then for each such way, find valid n.
  
  # Let's compute all divisors of 2014:
  divisors_2014 = []
  (1..2014).each do |i|
    if 2014 % i == 0
      divisors_2014 << i
    end
  end
  
  # For each way to write 2014 = d1 × d2 × ... × dk, 
  # we want n = p1^(d1-1) × p2^(d2-1) × ... × pk^(dk-1)
  # where p1 < p2 < ... < pk are primes
  
  # But we also need to be careful about the constraint n <= 10^10
  
  # Let's use a better approach:
  # We know that 2014 = 2 × 19 × 53
  # The divisors are: 1, 2, 19, 38, 53, 106, 1007, 2014
  
  # All possible factorizations of 2014 into >= 2 factors:
  # 2014 = 2 × 1007 (2 factors)
  # 2014 = 19 × 106 (2 factors)
  # 2014 = 53 × 38 (2 factors)
  # 2014 = 2 × 19 × 53 (3 factors)
  
  # Actually, let's just compute it properly:
  # 2014 = 2 × 19 × 53 = 2 × 1007 = 19 × 106 = 53 × 38
  
  # For a more complete approach:
  # We need to consider all possible ways to write 2014 = d1 × d2 × ... × dk
  # where each di ≥ 2
  
  # Let's compute the divisors properly and generate all combinations:
  
  # Let's try a different approach: 
  # Generate all valid combinations of exponents such that product of (exponent+1) = 2014
  
  # Let's just do a brute force approach for the specific case:
  result = []
  
  # Case 1: n = p^2013 (since 2014 = 2014)
  # n = 2^2013 = 2^2013
  if 2**2013 <= 10**10
    result << 2**2013
  end
  
  # Case 2: n = p^1006 × q^1 (since 2014 = 2 × 1007)
  # We need p^1006 × q^1 <= 10^10
  # This is computationally intensive to enumerate all, so let's be smarter
  
  # Actually, let's implement a cleaner solution:
  # We need to find all numbers n <= 10^10 such that d(n) = 2014
  
  # The most efficient approach:
  # Find all ways to write 2014 = (a1+1)(a2+1)...(ak+1) where ai >= 0
  # Then for each such way, we generate n = p1^a1 × p2^a2 × ... × pk^ak
  # where p1 < p2 < ... < pk are primes
  
  # Let's compute the divisors of 2014:
  divs = []
  (1..2014).each { |i| divs << i if 2014 % i == 0 }
  
  # Generate all partitions of 2014 into factors >= 2
  def generate_partitions(n, min_factor = 2, current = [])
    return [current] if n == 1
    partitions = []
    (min_factor..n).each do |i|
      if n % i == 0
        partitions.concat(generate_partitions(n / i, i, current + [i]))
      end
    end
    partitions
  end
  
  partitions = generate_partitions(2014)
  
  # For each partition, we need to generate the corresponding numbers
  # This is quite complex, so let's think of a better way:
  
  # Since 2014 = 2 × 19 × 53, we can have:
  # 1. n = p^2013 (where p is prime)
  # 2. n = p^1006 × q^1 (where p < q are primes)  
  # 3. n = p^105 × q^18 (where p < q are primes)
  # 4. n = p^37 × q^52 (where p < q are primes)
  # 5. n = p^1 × q^18 × r^52 (where p < q < r are primes)
  
  # Let's implement this more carefully:
  
  primes = []
  (2..100000).each do |i|
    is_prime = true
    (2..Math.sqrt(i)).each do |j|
      if i % j == 0
        is_prime = false
        break
      end
    end
    primes << i if is_prime
  end
  primes = primes.first(10000) # Get first 10000 primes
  
  sum = 0
  
  # Case 1: n = p^2013
  primes.each do |p|
    n = p**2013
    break if n > 10**10
    sum += n
  end
  
  # Case 2: n = p^1006 × q^1
  primes.each_with_index do |p, i|
    break if p**1006 > 10**10
    (i+1).upto(primes.length-1) do |j|
      q = primes[j]
      n = p**1006 * q
      break if n > 10**10
      sum += n
    end
  end
  
  # Case 3: n = p^105 × q^18  
  primes.each_with_index do |p, i|
    break if p**105 > 10**10
    (i+1).upto(primes.length-1) do |j|
      q = primes[j]
      n = p**105 * q**18
      break if n > 10**10
      sum += n
    end
  end
  
  # Case 4: n = p^37 × q^52
  primes.each_with_index do |p, i|
    break if p**37 > 10**10
    (i+1).upto(primes.length-1) do |j|
      q = primes[j]
      n = p**37 * q**52
      break if n > 10**10
      sum += n
    end
  end
  
  # Case 5: n = p^1 × q^18 × r^52
  primes.each_with_index do |p, i|
    break if p > 10**10
    (i+1).upto(primes.length-1) do |j|
      break if p * primes[j]**18 > 10**10
      (j+1).upto(primes.length-1) do |k|
        n = p * primes[j]**18 * primes[k]**52
        break if n > 10**10
        sum += n
      end
    end
  end
  
  sum
end

# Let me simplify and write a cleaner solution:

def solve_euler_581
  # 2014 = 2 × 19 × 53
  # The possible divisor structures are:
  # 1. (2014) -> n = p^2013
  # 2. (2, 1007) -> n = p^1 × q^1006  
  # 3. (19, 106) -> n = p^18 × q^105
  # 4. (53, 38) -> n = p^52 × q^37
  # 5. (2, 19, 53) -> n = p^1 × q^18 × r^52
  
  # Generate primes up to reasonable limit
  def sieve(limit)
    sieve = Array.new(limit + 1, true)
    sieve[0] = sieve[1] = false
    (2..Math.sqrt(limit)).each do |i|
      if sieve[i]
        (i*i).step(limit, i) { |j| sieve[j] = false }
      end
    end
    (2..limit).select { |i| sieve[i] }
  end
  
  primes = sieve(100000)
  
  # We need to be more careful about the limits
  sum = 0
  
  # Case 1: n = p^2013
  primes.each do |p|
    n = p**2013
    break if n > 10**10
    sum += n
  end
  
  # Case 2: n = p^1006 × q^1
  primes.each_with_index do |p, i|
    break if p**1006 > 10**10
    (i+1).upto(primes.length-1) do |j|
      q = primes[j]
      n = p**1006 * q
      break if n > 10**10
      sum += n
    end
  end
  
  # Case 3: n = p^105 × q^18
  primes.each_with_index do |p, i|
    break if p**105 > 10**10
    (i+1).upto(primes.length-1) do |j|
      q = primes[j]
      n = p**105 * q**18
      break if n > 10**10
      sum += n
    end
  end
  
  # Case 4: n = p^37 × q^52
  primes.each_with_index do |p, i|
    break if p**37 > 10**10
    (i+1).upto(primes.length-1) do |j|
      q = primes[j]
      n = p**37 * q**52
      break if n > 10**10
      sum += n
    end
  end
  
  # Case 5: n = p^1 × q^18 × r^52
  primes.each_with_index do |p, i|
    break if p > 10**10
    (i+1).upto(primes.length-1) do |j|
      break if p * primes[j]**18 > 10**10
      (j+1).upto(primes.length-1) do |k|
        n = p * primes[j]**18 * primes[k]**52
        break if n > 10**10
        sum += n
      end
    end
  end
  
  sum
end

puts solve_euler_581
```

Wait, let me reconsider the problem more carefully. The answer is much more complex to compute. Let me write a better approach:

```ruby
# Better approach for Euler 581
def solve_euler_581
  # Find all numbers n <= 10^10 such that d(n) = 2014
  # 2014 = 2 × 19 × 53
  
  # Generate primes
  def sieve(n)
    sieve = Array.new(n + 1, true)
    sieve[0] = sieve[1] = false
    (2..Math.sqrt(n)).each do |i|
      if sieve[i]
        (i*i).step(n, i) { |j| sieve[j] = false }
      end
    end
    (2..n).select { |i| sieve[i] }
  end
  
  primes = sieve(100000)
  
  # The divisor function d(n) = 201