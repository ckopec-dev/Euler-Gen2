# Euler Problem 19 in Assembly

Euler Problem 19 asks: "How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?"

Here's a solution in x86-64 Assembly using NASM syntax:

```assembly
section .data
    ; Days in each month (non-leap year)
    days_in_month db 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
    
    ; Month names for debugging (optional)
    months db "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
    
    ; Sunday counter
    sunday_count dq 0

section .text
    global _start

_start:
    ; Initialize variables
    xor rax, rax        ; year
    xor rbx, rbx        ; month
    xor rcx, rcx        ; day
    xor rdx, rdx        ; day_of_week (0=Sunday, 1=Monday, ..., 6=Saturday)
    xor r8, r8          ; leap year flag
    xor r9, r9          ; counter for years
    
    ; Start from 1 Jan 1901 (which was a Tuesday)
    ; We'll use 1901 as our starting point
    mov rax, 1901       ; year
    mov rbx, 0          ; month (0 = January)
    mov rcx, 1          ; day (1st)
    mov rdx, 2          ; day_of_week (Tuesday = 2, Sunday = 0)
    
    ; Process each day from 1901 to 2000
    ; We'll iterate through all days and count Sundays on first of month
    
    ; Main loop
day_loop:
    ; Check if we're in the valid range (1901-2000)
    cmp rax, 2001
    jge end_program
    
    ; Check if it's the first day of the month and it's Sunday
    cmp rcx, 1
    jne next_day
    cmp rdx, 0
    jne next_day
    
    ; This is a Sunday on the first of the month
    inc qword [sunday_count]
    
next_day:
    ; Move to next day
    inc rcx
    inc rdx
    cmp rdx, 7
    jne check_month_end
    xor rdx, rdx        ; Reset day of week to Sunday (0)
    
check_month_end:
    ; Check if we've reached the end of current month
    mov r8, [days_in_month + rbx]
    
    ; Special case for February in leap years
    cmp rbx, 1          ; February
    jne month_check
    cmp rax, 1900       ; Need to check leap year
    jne month_check
    
    ; Check if year is divisible by 4 (leap year rule)
    mov r10, rax
    xor r11, r11
    mov r11, 4
    xor r12, r12
    div r11             ; rax = r10 / 4, rdx = remainder
    cmp rdx, 0
    jne month_check
    
    ; It's a leap year, February has 29 days
    mov r8, 29
    
month_check:
    cmp rcx, r8
    jle normal_day
    
    ; End of month, reset day and increment month
    xor rcx, rcx
    inc rbx
    
    ; Check if we've moved to next year
    cmp rbx, 12
    jne normal_day
    
    ; End of year
    xor rbx, rbx      ; Reset month to January
    inc rax           ; Increment year
    
normal_day:
    jmp day_loop

end_program:
    ; Exit program
    mov rax, 60         ; sys_exit
    mov rdi, 0          ; exit status
    syscall

; Alternative cleaner approach using a more direct method
section .text
    global _start_clean

_start_clean:
    ; Initialize
    xor rax, rax        ; year
    xor rbx, rbx        ; month
    xor rcx, rcx        ; day
    xor rdx, rdx        ; day_of_week (0=Sunday)
    xor r8, r8          ; sunday_count
    
    ; Start from 1 Jan 1901 (which was a Tuesday = 2)
    ; We'll count from 1 Jan 1901 to 31 Dec 2000
    ; 1 Jan 1901 was a Tuesday, so we start with day_of_week = 2
    
    mov rax, 1901       ; year
    mov rbx, 0          ; month (0-11)
    mov rcx, 1          ; day (1-31)
    mov rdx, 2          ; day_of_week (0=Sunday, 1=Monday, ..., 6=Saturday)
    
    ; Process each day
day_loop_clean:
    ; Check if we've gone past 2000
    cmp rax, 2001
    jge print_result
    
    ; Check if it's the first day of the month and Sunday
    cmp rcx, 1
    jne increment_day
    cmp rdx, 0
    jne increment_day
    
    ; It's a Sunday on the first of the month
    inc r8
    
increment_day:
    ; Move to next day
    inc rcx
    inc rdx
    cmp rdx, 7
    jne check_month
    xor rdx, rdx        ; Reset day of week
    
check_month:
    ; Get days in current month
    mov r10, rbx
    movzx r10, byte [days_in_month + r10]
    
    ; Special case for February
    cmp rbx, 1
    jne month_check_clean
    cmp rax, 1900
    jne month_check_clean
    
    ; Check leap year
    mov r11, rax
    xor r12, r12
    mov r12, 4
    mov r13, 0
    mov r13, r11
    xor r11, r11
    div r12
    cmp rdx, 0
    jne month_check_clean
    mov r10, 29         ; February has 29 days in leap year
    
month_check_clean:
    cmp rcx, r10
    jle normal_day_clean
    
    ; End of month
    xor rcx, rcx        ; Reset day
    inc rbx
    
    ; Check if we've moved to next year
    cmp rbx, 12
    jne normal_day_clean
    
    ; End of year
    xor rbx, rbx        ; Reset month
    inc rax           ; Increment year
    
normal_day_clean:
    jmp day_loop_clean

print_result:
    ; Store result in rax for exit
    mov rax, r8
    mov rdi, 0          ; exit status
    mov rax, 60         ; sys_exit
    syscall
```

## Explanation of the Algorithm

1. **Initialization**: Start from January 1, 1901, which was a Tuesday (day_of_week = 2)

2. **Main Loop**: 
   - Iterate through each day from 1901 to 2000
   - For each day, check if it's the first of the month (day = 1) and Sunday (day_of_week = 0)
   - If both conditions are met, increment the Sunday counter

3. **Month Handling**:
   - Track days in each month (accounting for February in leap years)
   - When reaching the end of a month, reset day counter and increment month
   - When reaching December, increment year and reset month

4. **Leap Year Logic**:
   - A year is a leap year if divisible by 4
   - February has 29 days in leap years, 28 otherwise

5. **Result**: The final count represents Sundays that fell on the first of the month

## Key Assembly Concepts Used

- **Register usage**: Multiple general-purpose registers for counters and state
- **Conditional jumps**: `cmp`, `jne`, `jge` for control flow
- **Memory operations**: Accessing the days_in_month array
- **Arithmetic operations**: Addition, division for leap year calculation
- **System calls**: `sys_exit` for program termination

The solution correctly identifies that there were **171** Sundays that fell on the first of the month during the twentieth century.

