# Euler Problem 902 Solution in Assembly

I'll solve Euler Problem 902, which asks for the sum of all numbers n such that φ(n) = n - 1, where φ is Euler's totient function.

## Problem Understanding

We need to find numbers n where φ(n) = n - 1. This means that all numbers less than n that are coprime to n are exactly n-1 numbers, which happens only when n is prime.

Let me provide a complete assembly solution:

```assembly
.model small
.stack 100h

.data
    result dd 0
    max_num dw 1000000
    primes db 100000 dup(0)  ; Array to store primes
    prime_count dw 0
    buffer db 20 dup(?)

.code
main proc
    mov ax, @data
    mov ds, ax
    
    ; Find all primes up to max_num
    call sieve_of_eratosthenes
    
    ; Sum all primes (since φ(p) = p-1 for primes)
    call sum_primes
    
    ; Print result
    call print_result
    
    mov ah, 4Ch
    int 21h
main endp

; Sieve of Eratosthenes to find all primes up to max_num
sieve_of_eratosthenes proc
    push ax
    push bx
    push cx
    push dx
    
    ; Initialize array - set all to 1 (prime)
    mov cx, max_num
    mov di, 0
    mov bx, 0
    
init_loop:
    cmp di, max_num
    jge init_done
    mov primes[di], 1
    inc di
    jmp init_loop
init_done:
    
    ; 0 and 1 are not prime
    mov primes[0], 0
    mov primes[1], 0
    
    ; Sieve process
    mov bx, 2
outer_loop:
    cmp bx, max_num
    jge outer_done
    
    cmp primes[bx], 1
    jne next_outer
    
    ; Mark multiples of bx as not prime
    mov cx, bx
    mov dx, bx
    mul dx
    mov dx, ax
    
inner_loop:
    cmp dx, max_num
    jge inner_done
    
    mov primes[dx], 0
    add dx, bx
    jmp inner_loop
inner_done:
    
next_outer:
    inc bx
    jmp outer_loop
outer_done:
    
    ; Count primes and store them
    mov cx, 0
    mov di, 0
    mov word ptr [prime_count], 0
    
count_primes:
    cmp cx, max_num
    jge count_done
    
    cmp primes[cx], 1
    jne next_count
    
    mov primes[di], cl
    inc di
    inc word ptr [prime_count]
    
next_count:
    inc cx
    jmp count_primes
count_done:
    
    pop dx
    pop cx
    pop bx
    pop ax
    ret
sieve_of_eratosthenes endp

; Sum all primes found
sum_primes proc
    push ax
    push bx
    push cx
    push dx
    
    mov bx, 0
    mov cx, 0
    mov dx, 0
    
sum_loop:
    cmp bx, word ptr [prime_count]
    jge sum_done
    
    mov al, primes[bx]
    mov ah, 0
    add dx, ax
    adc cx, 0
    
    inc bx
    jmp sum_loop
sum_done:
    
    ; Store result
    mov result, dx
    mov result+2, cx
    
    pop dx
    pop cx
    pop bx
    pop ax
    ret
sum_primes endp

; Print the result
print_result proc
    push ax
    push bx
    push cx
    push dx
    
    ; Convert result to string
    mov ax, result
    mov bx, 10
    mov cx, 0
    
convert_loop:
    xor dx, dx
    div bx
    add dl, '0'
    push dx
    inc cx
    cmp ax, 0
    jne convert_loop
    
print_loop:
    cmp cx, 0
    je print_done
    pop dx
    mov ah, 2
    int 21h
    dec cx
    jmp print_loop
print_done:
    
    ; Print newline
    mov dl, 13
    mov ah, 2
    int 21h
    mov dl, 10
    mov ah, 2
    int 21h
    
    pop dx
    pop cx
    pop bx
    pop ax
    ret
print_result endp

end main
```

## Explanation

This assembly program solves Euler Problem 902 by:

1. **Understanding the mathematical property**: φ(n) = n - 1 if and only if n is prime
2. **Finding all primes**: Uses the Sieve of Eratosthenes algorithm to find all primes up to the given limit
3. **Summing the primes**: Since all primes satisfy the condition, we simply sum them all

## Key Features

- Uses the Sieve of Eratosthenes for efficient prime finding
- Implements proper data structures for storing primes
- Handles large numbers through 32-bit arithmetic
- Includes proper output formatting

## Mathematical Insight

The key insight for this problem is that φ(n) = n - 1 if and only if n is prime. This is because:
- For a prime p, all numbers from 1 to p-1 are coprime to p
- Therefore φ(p) = p - 1
- For composite numbers, φ(n) < n - 1

## Runtime Complexity

- Sieve of Eratosthenes: O(n log log n)
- Summing primes: O(π(n)) where π(n) is the number of primes ≤ n
- Overall: O(n log log n)

This solution efficiently computes the sum of all numbers n such that φ(n) = n - 1, which are exactly the prime numbers.

