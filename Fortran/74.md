# Euler Problem 74 Solution in Fortran

Euler Problem 74 asks: "How many chains, with a starting number below one million, contain exactly sixty non-repeating terms?"

Let me solve this step by step:

```fortran
program euler74
    implicit none
    integer, parameter :: max_n = 1000000
    integer :: i, j, count, chain_length
    integer :: current, next_num
    integer :: result
    integer, dimension(max_n) :: chain_lengths
    integer, dimension(10) :: factorial
    logical, dimension(max_n) :: visited
    
    ! Initialize factorial array
    factorial(0) = 1
    do i = 1, 9
        factorial(i) = i * factorial(i-1)
    end do
    
    ! Initialize chain_lengths array
    chain_lengths = 0
    
    result = 0
    
    ! For each number below one million
    do i = 1, max_n - 1
        if (chain_lengths(i) == 0) then
            ! Start new chain
            current = i
            j = 1
            visited = .false.
            
            ! Follow the chain until we hit a repeated number or exceed 60 terms
            do while (.true.)
                if (visited(current)) then
                    ! Found a cycle
                    chain_length = j - 1  ! Subtract 1 because we're counting the repeated element
                    ! Backtrack and fill in chain lengths for all elements in this chain
                    chain_lengths(i) = chain_length
                    exit
                end if
                
                if (j > 60) then
                    ! Chain too long, don't count it
                    chain_lengths(i) = 0
                    exit
                end if
                
                visited(current) = .true.
                
                ! Calculate next number in chain
                next_num = 0
                do while (current > 0)
                    next_num = next_num + factorial(mod(current, 10))
                    current = current / 10
                end do
                
                current = next_num
                j = j + 1
            end do
            
            ! If we found a valid chain of exactly 60 terms
            if (chain_lengths(i) == 60) then
                result = result + 1
            end if
        end if
    end do
    
    print *, 'Result:', result
end program euler74
```

Wait, let me reconsider this approach. The problem requires counting chains that contain exactly 60 non-repeating terms, not just any chain that has 60 terms. Let me correct the solution:

```fortran
program euler74
    implicit none
    integer, parameter :: max_n = 1000000
    integer :: i, j, count, chain_length
    integer :: current, next_num
    integer :: result
    integer, dimension(max_n) :: chain_lengths
    integer, dimension(10) :: factorial
    logical, dimension(max_n) :: visited
    
    ! Precompute factorials
    factorial(0) = 1
    do i = 1, 9
        factorial(i) = i * factorial(i-1)
    end do
    
    ! Initialize chain_lengths array
    chain_lengths = 0
    
    result = 0
    
    ! For each number below one million
    do i = 1, max_n - 1
        if (chain_lengths(i) == 0) then
            ! Start new chain
            current = i
            j = 1
            visited = .false.
            ! Store the chain to calculate its length
            integer, dimension(max_n) :: temp_chain
            integer :: chain_size
            
            chain_size = 0
            
            ! Follow the chain until we hit a repeated number
            do while (.true.)
                if (visited(current)) then
                    ! Found a cycle - this is the chain length
                    chain_length = j - 1  ! Subtract 1 because we're counting the repeated element
                    ! Fill in chain lengths for all elements in this chain
                    do k = 1, chain_size
                        if (temp_chain(k) < max_n) then
                            chain_lengths(temp_chain(k)) = chain_length
                        end if
                    end do
                    exit
                end if
                
                if (j > 60) then
                    ! Chain too long
                    chain_length = 0
                    exit
                end if
                
                visited(current) = .true.
                chain_size = chain_size + 1
                temp_chain(chain_size) = current
                
                ! Calculate next number in chain
                next_num = 0
                do while (current > 0)
                    next_num = next_num + factorial(mod(current, 10))
                    current = current / 10
                end do
                
                current = next_num
                j = j + 1
            end do
            
            ! If we found a valid chain of exactly 60 terms
            if (chain_length == 60) then
                result = result + 1
            end if
        end if
    end do
    
    print *, 'Result:', result
end program euler74
```

Actually, let me provide a cleaner and more correct solution:

```fortran
program euler74
    implicit none
    integer, parameter :: max_n = 1000000
    integer :: i, j, chain_length, current, next_num, result
    integer, dimension(10) :: factorial
    integer, dimension(max_n) :: chain_lengths
    logical, dimension(max_n) :: visited
    
    ! Precompute factorials
    factorial(0) = 1
    do i = 1, 9
        factorial(i) = i * factorial(i-1)
    end do
    
    ! Initialize arrays
    chain_lengths = 0
    result = 0
    
    ! For each number below one million
    do i = 1, max_n - 1
        if (chain_lengths(i) == 0) then
            ! Start following the chain from i
            current = i
            j = 1
            visited = .false.
            
            ! Keep track of chain elements for backtracking
            integer, dimension(max_n) :: chain_elements
            integer :: chain_count
            
            chain_count = 0
            
            ! Follow the chain until we find a repeated element or exceed 60 terms
            do while (.true.)
                if (visited(current)) then
                    ! Found a repeated element - calculate chain length
                    chain_length = j - 1
                    ! Mark all elements in this chain with the same length
                    do k = 1, chain_count
                        if (chain_elements(k) < max_n) then
                            chain_lengths(chain_elements(k)) = chain_length
                        end if
                    end do
                    exit
                end if
                
                if (j > 60) then
                    ! Chain too long - mark as 0 to indicate invalid
                    chain_length = 0
                    do k = 1, chain_count
                        if (chain_elements(k) < max_n) then
                            chain_lengths(chain_elements(k)) = 0
                        end if
                    end do
                    exit
                end if
                
                visited(current) = .true.
                chain_count = chain_count + 1
                chain_elements(chain_count) = current
                
                ! Calculate next number in chain
                next_num = 0
                j = current
                do while (j > 0)
                    next_num = next_num + factorial(mod(j, 10))
                    j = j / 10
                end do
                
                current = next_num
            end do
            
            ! If this chain has exactly 60 terms, increment result
            if (chain_length == 60) then
                result = result + 1
            end if
        end if
    end do
    
    print *, 'Result:', result
end program euler74
```

