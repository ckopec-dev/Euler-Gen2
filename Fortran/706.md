# Euler Problem 706 Solution in Fortran

Euler Problem 706 asks us to find the number of ways to write a number as a sum of powers of 2, where each power can be used at most twice.

Let me solve this step by step:

```fortran
program euler706
    implicit none
    integer, parameter :: MAX_N = 1000000
    integer :: n, i, j, k
    integer :: ways(MAX_N + 1)
    integer :: result
    
    ! Initialize the ways array
    do i = 0, MAX_N
        ways(i) = 0
    end do
    
    ! Base case: 0 can be represented in 1 way (empty sum)
    ways(0) = 1
    
    ! For each power of 2 (2^0, 2^1, 2^2, ...)
    i = 1
    do while (i <= MAX_N)
        ! For each number from i to MAX_N
        do j = i, MAX_N
            ! Add the number of ways to form (j - i) to current ways
            ways(j) = ways(j) + ways(j - i)
        end do
        ! But we can only use each power at most twice
        ! So we need to adjust for the constraint
        i = i * 2
    end do
    
    ! Actually, we need to be more careful about the constraint
    ! Let's reset and do it properly
    do i = 0, MAX_N
        ways(i) = 0
    end do
    ways(0) = 1
    
    ! Now we'll use dynamic programming with constraint
    ! Each power can be used at most twice
    i = 1
    do while (i <= MAX_N)
        ! Process from right to left to avoid double counting
        do j = MAX_N, i, -1
            ! We can use 0, 1, or 2 copies of i
            do k = 1, min(2, j/i)
                ways(j) = ways(j) + ways(j - k*i)
            end do
        end do
        i = i * 2
    end do
    
    ! But this is still not right. Let me re-read the problem.
    ! The problem is asking for ways to write n as sum of powers of 2
    ! where each power can be used at most twice.
    
    ! Let me solve it properly using the correct DP approach:
    ! Initialize
    do i = 0, MAX_N
        ways(i) = 0
    end do
    ways(0) = 1
    
    ! For each power of 2, we can use it 0, 1, or 2 times
    i = 1
    do while (i <= MAX_N)
        ! Process from right to left to avoid using updated values
        do j = MAX_N, i, -1
            ! Add ways to form (j - i), (j - 2*i) etc.
            ! We can use 1 or 2 copies of power i
            if (j >= i) then
                ways(j) = ways(j) + ways(j - i)
            end if
            if (j >= 2*i) then
                ways(j) = ways(j) + ways(j - 2*i)
            end if
        end do
        i = i * 2
    end do
    
    ! The answer for n = 10^6
    result = ways(1000000)
    print *, 'Result for n = 1000000:', result
    
    ! Let's also check smaller cases to verify
    do i = 0, 10
        ways(i) = 0
    end do
    ways(0) = 1
    
    i = 1
    do while (i <= 10)
        do j = 10, i, -1
            if (j >= i) then
                ways(j) = ways(j) + ways(j - i)
            end if
            if (j >= 2*i) then
                ways(j) = ways(j) + ways(j - 2*i)
            end if
        end do
        i = i * 2
    end do
    
    print *, 'Verification for n = 10:'
    do i = 0, 10
        print *, 'ways(', i, ') = ', ways(i)
    end do
    
end program euler706
```

Wait, I need to reconsider the approach. Let me think more carefully about what we're trying to compute.

Looking at this more carefully, this is a classic dynamic programming problem where we want to count the number of ways to represent a number as a sum of powers of 2 with each power used at most twice.

```fortran
program euler706
    implicit none
    integer, parameter :: MAX_N = 1000000
    integer :: i, j, k, power
    integer :: ways(MAX_N + 1)
    integer :: result
    
    ! Initialize the ways array
    do i = 0, MAX_N
        ways(i) = 0
    end do
    
    ! Base case
    ways(0) = 1
    
    ! For each power of 2 (1, 2, 4, 8, 16, ...)
    power = 1
    do while (power <= MAX_N)
        ! Process from right to left to avoid using updated values in same iteration
        ! For each number from MAX_N down to power
        do j = MAX_N, power, -1
            ! We can use 0, 1, or 2 copies of this power
            ! But we only update if we have at least 1 copy
            if (j >= power) then
                ways(j) = ways(j) + ways(j - power)
            end if
            if (j >= 2 * power) then
                ways(j) = ways(j) + ways(j - 2 * power)
            end if
        end do
        power = power * 2
    end do
    
    ! The answer for n = 10^6
    result = ways(MAX_N)
    print *, 'Euler Problem 706 Answer:', result
    
end program euler706
```

Actually, I'm still not implementing the constraint correctly. Let me approach this more systematically:

```fortran
program euler706
    implicit none
    integer, parameter :: MAX_N = 1000000
    integer :: i, j, power
    integer :: ways(MAX_N + 1)
    integer :: result
    
    ! Initialize all values to 0
    do i = 0, MAX_N
        ways(i) = 0
    end do
    
    ! Base case: there is 1 way to make 0 (using no terms)
    ways(0) = 1
    
    ! Process each power of 2 (1, 2, 4, 8, 16, ...)
    power = 1
    do while (power <= MAX_N)
        ! Process each number from MAX_N down to power
        ! This ensures we don't double-count
        do j = MAX_N, power, -1
            ! Add ways to form (j - power) using 1 copy of current power
            if (j >= power) then
                ways(j) = ways(j) + ways(j - power)
            end if
            ! Add ways to form (j - 2*power) using 2 copies of current power
            if (j >= 2 * power) then
                ways(j) = ways(j) + ways(j - 2 * power)
            end if
        end do
        power = power * 2
    end do
    
    ! The result is the number of ways to represent 1000000
    result = ways(MAX_N)
    print *, 'Euler Problem 706 Result:', result
    
end program euler706
```

