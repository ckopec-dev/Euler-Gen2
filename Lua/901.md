# Euler Problem 901 Solution in Lua

I need to solve Euler Problem 901, which asks for the number of ways to arrange the numbers 1, 2, ..., n in a row such that the sum of any two adjacent numbers is a perfect square.

Let me break this down:
1. For a given n, I need to find all valid arrangements of numbers 1 to n
2. In each arrangement, adjacent numbers must sum to a perfect square
3. This is essentially finding Hamiltonian paths in a graph where edges connect numbers that sum to perfect squares

```lua
function is_perfect_square(n)
    if n < 0 then return false end
    local sqrt_n = math.sqrt(n)
    return sqrt_n == math.floor(sqrt_n)
end

function get_valid_neighbors(n)
    -- Create adjacency list for numbers 1 to n
    local neighbors = {}
    for i = 1, n do
        neighbors[i] = {}
        for j = 1, n do
            if i ~= j and is_perfect_square(i + j) then
                table.insert(neighbors[i], j)
            end
        end
    end
    return neighbors
end

function count_valid_arrangements(n)
    if n == 0 then return 0 end
    if n == 1 then return 1 end
    
    local neighbors = get_valid_neighbors(n)
    local count = 0
    
    -- Use backtracking to find all valid arrangements
    local used = {}
    local current_arrangement = {}
    
    function backtrack()
        if #current_arrangement == n then
            count = count + 1
            return
        end
        
        local last_number = current_arrangement[#current_arrangement]
        
        -- If this is the first number, try all possibilities
        if #current_arrangement == 0 then
            for i = 1, n do
                used[i] = true
                table.insert(current_arrangement, i)
                backtrack()
                table.remove(current_arrangement)
                used[i] = false
            end
        else
            -- Try all valid neighbors of the last number
            for _, next_num in ipairs(neighbors[last_number]) do
                if not used[next_num] then
                    used[next_num] = true
                    table.insert(current_arrangement, next_num)
                    backtrack()
                    table.remove(current_arrangement)
                    used[next_num] = false
                end
            end
        end
    end
    
    backtrack()
    return count
end

-- For Euler Problem 901, we need to find the answer for n = 30
-- Let's calculate it
local result = count_valid_arrangements(30)
print("Number of valid arrangements for n = 30: " .. result)

-- Let's also test with smaller values to verify our approach
print("n = 1:", count_valid_arrangements(1))
print("n = 2:", count_valid_arrangements(2))
print("n = 3:", count_valid_arrangements(3))
print("n = 4:", count_valid_arrangements(4))
```

Wait, let me reconsider the problem. Looking at Euler Problem 901 more carefully, it might be asking for something different. Let me re-read and solve it properly:

```lua
function is_perfect_square(n)
    if n < 0 then return false end
    local sqrt_n = math.sqrt(n)
    return sqrt_n == math.floor(sqrt_n)
end

function get_valid_pairs(n)
    -- Find all pairs of numbers from 1 to n that sum to a perfect square
    local pairs = {}
    for i = 1, n do
        for j = i + 1, n do
            if is_perfect_square(i + j) then
                table.insert(pairs, {i, j})
            end
        end
    end
    return pairs
end

function count_valid_arrangements(n)
    if n == 0 then return 0 end
    if n == 1 then return 1 end
    
    -- Build adjacency list for the graph
    local adj = {}
    for i = 1, n do
        adj[i] = {}
    end
    
    -- Find all valid adjacent pairs
    for i = 1, n do
        for j = i + 1, n do
            if is_perfect_square(i + j) then
                table.insert(adj[i], j)
                table.insert(adj[j], i)
            end
        end
    end
    
    -- Count Hamiltonian paths using backtracking
    local count = 0
    local used = {}
    local path = {}
    
    function dfs(node)
        table.insert(path, node)
        used[node] = true
        
        if #path == n then
            count = count + 1
        else
            for _, neighbor in ipairs(adj[node]) do
                if not used[neighbor] then
                    dfs(neighbor)
                end
            end
        end
        
        -- Backtrack
        table.remove(path)
        used[node] = false
    end
    
    -- Start DFS from each node
    for i = 1, n do
        dfs(i)
    end
    
    return count
end

-- Solve for n = 30 (Euler Problem 901)
local result = count_valid_arrangements(30)
print("Euler Problem 901 answer: " .. result)

-- For verification, let's also look at small cases
print("Small test cases:")
for i = 1, 5 do
    print("n = " .. i .. ": " .. count_valid_arrangements(i))
end
```

Actually, let me approach this more systematically and provide the final clean solution:

```lua
function is_perfect_square(n)
    if n < 0 then return false end
    local sqrt_n = math.sqrt(n)
    return sqrt_n == math.floor(sqrt_n)
end

function count_valid_arrangements(n)
    if n == 0 then return 0 end
    if n == 1 then return 1 end
    
    -- Create adjacency list: which numbers can be adjacent
    local adj = {}
    for i = 1, n do
        adj[i] = {}
        for j = 1, n do
            if i ~= j and is_perfect_square(i + j) then
                table.insert(adj[i], j)
            end
        end
    end
    
    -- Count all Hamiltonian paths using backtracking
    local count = 0
    local used = {}
    local path = {}
    
    function backtrack(current_node)
        table.insert(path, current_node)
        used[current_node] = true
        
        if #path == n then
            count = count + 1
        else
            for _, next_node in ipairs(adj[current_node]) do
                if not used[next_node] then
                    backtrack(next_node)
                end
            end
        end
        
        -- Backtrack
        table.remove(path)
        used[current_node] = false
    end
    
    -- Try starting from each node
    for i = 1, n do
        backtrack(i)
    end
    
    return count
end

-- The answer to Euler Problem 901
local answer = count_valid_arrangements(30)
print("Euler Problem 901 answer: " .. answer)
```

The solution works by:

1. **Building a graph**: For each pair of numbers from 1 to n, if their sum is a perfect square, we connect them in the graph
2. **Finding Hamiltonian paths**: Using backtracking to find all possible arrangements where each adjacent pair sums to a perfect square
3. **Counting valid arrangements**: The total count of such valid permutations

For n = 30, this approach will compute the exact answer to Euler Problem 901.

