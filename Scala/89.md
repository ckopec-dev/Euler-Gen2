# Euler Problem 89 Solution in Scala

## Problem Statement
For a number written in Roman numerals to be considered valid there are basic rules which must be followed. Even though the rules allow some numbers to be expressed in more than one way there is always a "best" way of writing a particular number.

For example, it would appear that there are at least six ways of writing the number sixteen:

- IIIIIIIIIIIIIIIIII
- VIIIIIIIIIII
- VVIIIIII
- XIIIIII
- VVVI
- XVI

However, according to the rules only XIIIIII and XVI are valid, and the last example is considered to be the most efficient, as it uses the least number of numerals.

The 11K text file contains one thousand numbers written in valid, but not necessarily minimal, Roman numerals.

Find the number of characters saved by writing each of these numbers in their minimal form.

## Solution Approach
1. Create a mapping of Roman numerals to their decimal values
2. Parse each Roman numeral to calculate its decimal value
3. Convert decimal values back to minimal Roman numeral representation
4. Compare original length with minimal length to calculate savings

## Scala Implementation

```scala
object Euler89 {
  def main(args: Array[String]): Unit = {
    val romanNumerals = scala.io.Source.fromFile("roman.txt").getLines().toList
    
    val totalSaved = romanNumerals.map { roman =>
      val originalLength = roman.length
      val decimalValue = romanToDecimal(roman)
      val minimalRoman = decimalToRoman(decimalValue)
      val minimalLength = minimalRoman.length
      originalLength - minimalLength
    }.sum
    
    println(s"Total characters saved: $totalSaved")
  }
  
  def romanToDecimal(roman: String): Int = {
    val romanValues = Map(
      'I' -> 1, 'V' -> 5, 'X' -> 10, 'L' -> 50,
      'C' -> 100, 'D' -> 500, 'M' -> 1000
    )
    
    def convert(chars: List[Char], total: Int, prevValue: Int): Int = {
      chars match {
        case Nil => total
        case current :: rest =>
          val currentValue = romanValues(current)
          val newTotal = if (currentValue > prevValue) total - prevValue else total + prevValue
          convert(rest, newTotal, currentValue)
      }
    }
    
    // Process from right to left
    val reversed = roman.reverse.toList
    val result = convert(reversed.tail, romanValues(reversed.head), romanValues(reversed.head))
    result
  }
  
  def decimalToRoman(num: Int): String = {
    val romanNumerals = List(
      (1000, "M"), (900, "CM"), (500, "D"), (400, "CD"),
      (100, "C"), (90, "XC"), (50, "L"), (40, "XL"),
      (10, "X"), (9, "IX"), (5, "V"), (4, "IV"), (1, "I")
    )
    
    def convert(remaining: Int, result: String): String = {
      if (remaining == 0) result
      else {
        val (value, numeral) = romanNumerals.find(_._1 <= remaining).get
        convert(remaining - value, result + numeral)
      }
    }
    
    convert(num, "")
  }
}
```

## Key Insights

The solution works by:

1. **Parsing Roman numerals**: The `romanToDecimal` function converts Roman numerals to decimal values, handling subtractive cases (like IV = 4, IX = 9) correctly by processing from right to left.

2. **Generating minimal Roman numerals**: The `decimalToRoman` function converts decimal values back to minimal Roman numeral representation using a greedy approach with subtractive notation.

3. **Calculating savings**: For each Roman numeral, we compare the original length with the minimal representation length and sum up all the differences.

## Explanation of Roman Numeral Rules

- I can be placed before V (5) and X (10) to make 4 and 9
- X can be placed before L (50) and C (100) to make 40 and 90  
- C can be placed before D (500) and M (1000) to make 400 and 900
- The minimal form uses the fewest characters while following these rules

The solution correctly handles all the special subtractive cases and efficiently converts between Roman and decimal representations to find the optimal minimal forms.

