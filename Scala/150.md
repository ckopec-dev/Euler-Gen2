# Euler Problem 150 Solution in Scala

## Problem Statement
In a triangular array of positive and negative numbers, we wish to find a sub-triangle such that the sum of the numbers it contains is the smallest possible.

## Solution Approach
I'll solve this using dynamic programming with a triangular array structure. The key insight is to build a cumulative sum array and then check all possible sub-triangles.

```scala
object Euler150 {
  def main(args: Array[String]): Unit = {
    val triangle = generateTriangle()
    val result = findMinimalSubTriangle(triangle)
    println(result)
  }
  
  def generateTriangle(): Array[Array[Int]] = {
    val rows = 1000
    val triangle = Array.ofDim[Int](rows)
    
    // Generate the triangle using the given formula
    var seed = 0
    for (i <- 0 until rows) {
      triangle(i) = new Array[Int](i + 1)
      for (j <- 0 to i) {
        seed = (615949 * seed + 797807) % (1 << 20)
        triangle(i)(j) = seed - (1 << 19)
      }
    }
    
    triangle
  }
  
  def findMinimalSubTriangle(triangle: Array[Array[Int]]): Long = {
    val rows = triangle.length
    val sums = Array.ofDim[Long](rows, rows)
    
    // Precompute prefix sums for each row
    for (i <- 0 until rows) {
      sums(i)(0) = triangle(i)(0)
      for (j <- 1 to i) {
        sums(i)(j) = sums(i)(j - 1) + triangle(i)(j)
      }
    }
    
    var minSum = Long.MaxValue
    
    // Check all possible sub-triangles
    for (i <- 0 until rows) {
      for (j <- 0 to i) {
        var currentSum = 0L
        for (k <- i until rows) {
          // Add the row k to current sub-triangle
          val start = j
          val end = j + (k - i)
          
          if (end < triangle(k).length) {
            val rowSum = if (start == 0) sums(k)(end) else sums(k)(end) - sums(k)(start - 1)
            currentSum += rowSum
            
            if (currentSum < minSum) {
              minSum = currentSum
            }
          }
        }
      }
    }
    
    minSum
  }
  
  // Alternative cleaner approach using cumulative sums
  def findMinimalSubTriangleOptimized(triangle: Array[Array[Int]]): Long = {
    val rows = triangle.length
    val cumulativeSums = Array.ofDim[Long](rows, rows)
    
    // Build cumulative sums for each row
    for (i <- 0 until rows) {
      cumulativeSums(i)(0) = triangle(i)(0)
      for (j <- 1 to i) {
        cumulativeSums(i)(j) = cumulativeSums(i)(j - 1) + triangle(i)(j)
      }
    }
    
    var minSum = Long.MaxValue
    
    // For each possible top vertex of sub-triangle
    for (topRow <- 0 until rows) {
      for (topCol <- 0 to topRow) {
        var currentSum = 0L
        
        // For each possible bottom vertex of sub-triangle
        for (bottomRow <- topRow until rows) {
          // Calculate sum of current sub-triangle
          val rowLength = bottomRow - topRow + 1
          val startCol = topCol
          val endCol = startCol + rowLength - 1
          
          if (endCol < triangle(bottomRow).length) {
            // Sum of the current row in sub-triangle
            val rowSum = if (startCol == 0) 
              cumulativeSums(bottomRow)(endCol)
            else 
              cumulativeSums(bottomRow)(endCol) - cumulativeSums(bottomRow)(startCol - 1)
            
            currentSum += rowSum
            
            if (currentSum < minSum) {
              minSum = currentSum
            }
          }
        }
      }
    }
    
    minSum
  }
}
```

Wait, let me reconsider this problem more carefully. Looking at the actual problem, I need to think about how to properly compute all triangular subregions.

```scala
object Euler150 {
  def main(args: Array[String]): Unit = {
    val triangle = generateTriangle()
    val result = findMinimalSubTriangle(triangle)
    println(s"Answer: $result")
  }
  
  def generateTriangle(): Array[Array[Int]] = {
    val rows = 1000
    val triangle = Array.ofDim[Int](rows)
    
    var seed = 0
    for (i <- 0 until rows) {
      triangle(i) = new Array[Int](i + 1)
      for (j <- 0 to i) {
        seed = (615949 * seed + 797807) % (1 << 20)
        triangle(i)(j) = seed - (1 << 19)
      }
    }
    
    triangle
  }
  
  def findMinimalSubTriangle(triangle: Array[Array[Int]]): Long = {
    val rows = triangle.length
    val sums = Array.ofDim[Long](rows, rows)
    
    // Precompute row sums for efficiency
    for (i <- 0 until rows) {
      sums(i)(0) = triangle(i)(0)
      for (j <- 1 to i) {
        sums(i)(j) = sums(i)(j - 1) + triangle(i)(j)
      }
    }
    
    var minSum = Long.MaxValue
    
    // Check all possible triangular sub-triangles
    for (i <- 0 until rows) { // top row
      for (j <- 0 to i) { // top column
        var currentSum = 0L
        var k = 0
        // For each possible size of triangle
        while (i + k < rows) {
          val currentRow = i + k
          val startCol = j
          val endCol = j + k
          
          if (endCol < triangle(currentRow).length) {
            // Calculate sum of this row in the sub-triangle
            val rowSum = if (startCol == 0) 
              sums(currentRow)(endCol)
            else 
              sums(currentRow)(endCol) - sums(currentRow)(startCol - 1)
            
            currentSum += rowSum
            
            if (currentSum < minSum) {
              minSum = currentSum
            }
          }
          k += 1
        }
      }
    }
    
    minSum
  }
}
```

Actually, let me provide a cleaner, more correct solution:

```scala
object Euler150 {
  def main(args: Array[String]): Unit = {
    val triangle = generateTriangle()
    val result = findMinimalSubTriangle(triangle)
    println(s"Answer: $result")
  }
  
  def generateTriangle(): Array[Array[Int]] = {
    val rows = 1000
    val triangle = Array.ofDim[Int](rows)
    
    var seed = 0
    for (i <- 0 until rows) {
      triangle(i) = new Array[Int](i + 1)
      for (j <- 0 to i) {
        seed = (615949 * seed + 797807) % (1 << 20)
        triangle(i)(j) = seed - (1 << 19)
      }
    }
    
    triangle
  }
  
  def findMinimalSubTriangle(triangle: Array[Array[Int]]): Long = {
    val rows = triangle.length
    
    // Precompute prefix sums for each row
    val prefixSums = Array.ofDim[Long](rows, rows)
    for (i <- 0 until rows) {
      prefixSums(i)(0) = triangle(i)(0)
      for (j <- 1 to i) {
        prefixSums(i)(j) = prefixSums(i)(j - 1) + triangle(i)(j)
      }
    }
    
    var minSum = Long.MaxValue
    
    // For each possible top vertex of triangular sub-triangle
    for (topRow <- 0 until rows) {
      for (topCol <- 0 to topRow) {
        var currentSum = 0L
        
        // For each possible size of triangle (height)
        for (height <- 1 until (rows - topRow + 1)) {
          val bottomRow = topRow + height - 1
          
          // Check if we can form a valid triangle
          if (bottomRow < rows) {
            // Calculate sum of this triangular sub-triangle
            val startCol = topCol
            val endCol = topCol + height - 1
            
            if (endCol < triangle(bottomRow).length) {
              // Sum the rows of the triangle
              for (row <- topRow to bottomRow) {
                val rowStart = startCol + (row - topRow)
                val rowEnd = startCol + (row - topRow) + (bottomRow - row)
                
                if (rowEnd < triangle(row).length) {
                  val rowSum = if (rowStart == 0) 
                    prefixSums(row)(rowEnd)
                  else 
                    prefixSums(row)(rowEnd) - prefixSums(row)(rowStart - 1)
                  
                  currentSum += rowSum
                }
              }
              
              if (currentSum < minSum) {
                minSum = currentSum
              }
            }
          }
        }
      }
    }
    
    minSum
  }
}
```

This solution:

1. **Generates the triangular array** using the given pseudo-random number generator
2. **Precomputes prefix sums** for efficient range sum queries
3. **Checks all possible triangular sub-triangles** by iterating through all possible top vertices and triangle sizes
4. **Computes the sum** of each triangular sub-triangle efficiently using prefix sums
5. **Tracks the minimum sum** encountered

The time complexity is O(n³) where n is the number of rows, and space complexity is O(n²) for storing the prefix sums.

