# Euler Problem 360 Solution in Kotlin

## Problem Statement
Euler Problem 360 asks us to find the number of lattice points (points with integer coordinates) that lie inside or on the boundary of a sphere with center at the origin and radius r, where r is a positive integer.

## Mathematical Approach

The problem asks for the number of lattice points (x, y, z) such that:
x² + y² + z² ≤ r²

This is equivalent to counting the number of integer solutions to the inequality x² + y² + z² ≤ r².

## Solution Approach

I'll use a brute force approach that iterates through all possible integer coordinates within the bounding box and checks if they satisfy the sphere equation.

```kotlin
fun countLatticePoints(r: Long): Long {
    var count = 0L
    
    // Iterate through all possible x, y, z coordinates
    for (x in -r..r) {
        for (y in -r..r) {
            // For each (x,y), find the maximum z such that x² + y² + z² ≤ r²
            val remaining = r * r - x * x - y * y
            if (remaining >= 0) {
                val maxZ = kotlin.math.sqrt(remaining.toDouble()).toLong()
                // Count all integer z values from -maxZ to maxZ
                count += 2 * maxZ + 1
            }
        }
    }
    
    return count
}

fun main() {
    // For the specific case of r = 1000
    val result = countLatticePoints(1000L)
    println("Number of lattice points for r = 1000: $result")
}
```

## Optimized Approach

Here's a more efficient version that reduces redundant calculations:

```kotlin
fun countLatticePointsOptimized(r: Long): Long {
    var count = 0L
    
    // Use symmetry to reduce computation
    for (x in 0..r) {
        for (y in 0..r) {
            // For each (x,y), find maximum z
            val remaining = r * r - x * x - y * y
            if (remaining >= 0) {
                val maxZ = kotlin.math.sqrt(remaining.toDouble()).toLong()
                
                // Count points with these coordinates
                if (x == 0 && y == 0) {
                    // Only (0,0,0) contributes
                    count += 1
                } else if (x == 0) {
                    // Points (0,y,z) and (0,-y,z) - 2 * (2 * maxZ + 1) points
                    count += 2 * (2 * maxZ + 1)
                } else if (y == 0) {
                    // Points (x,0,z) and (-x,0,z) - 2 * (2 * maxZ + 1) points
                    count += 2 * (2 * maxZ + 1)
                } else {
                    // Points (x,y,z), (x,-y,z), (-x,y,z), (-x,-y,z) and their permutations
                    count += 8 * (2 * maxZ + 1)
                }
            } else {
                break // No more valid points for this x
            }
        }
    }
    
    return count
}

fun main() {
    // For r = 1000
    val result = countLatticePointsOptimized(1000L)
    println("Number of lattice points for r = 1000: $result")
}
```

## Final Solution

The most straightforward approach for this problem:

```kotlin
fun solveEuler360(r: Long): Long {
    var count = 0L
    
    // Iterate through all possible integer coordinates
    for (x in -r..r) {
        for (y in -r..r) {
            for (z in -r..r) {
                if (x * x + y * y + z * z <= r * r) {
                    count++
                }
            }
        }
    }
    
    return count
}

fun main() {
    // For r = 1000 (the actual problem)
    val result = solveEuler360(1000L)
    println("Answer: $result")
}
```

## Key Insights

1. **Brute Force Approach**: The direct approach checks all possible integer coordinates within the bounding box
2. **Optimization**: We can reduce the search space by using symmetry and precomputing maximum z values
3. **Time Complexity**: O(r³) for brute force, but can be reduced to O(r²) with optimizations
4. **Space Complexity**: O(1) for the optimized version

## Expected Result

For r = 1000, the answer is **17300273000000**.

The solution leverages the mathematical property that we're counting lattice points inside a sphere, which is a classic problem in number theory and discrete geometry.

