# Euler Problem 948 Solution in Kotlin

I need to solve Euler Problem 948, which asks for the sum of all numbers n such that φ(n) = n - 1, where φ is Euler's totient function.

Let me first understand what φ(n) = n - 1 means:
- φ(n) counts the number of integers from 1 to n that are coprime to n
- If φ(n) = n - 1, then all numbers from 1 to n-1 are coprime to n
- This happens when n is a prime number (since for prime p, φ(p) = p - 1)

However, let me also check if there are other cases where φ(n) = n - 1.

For φ(n) = n - 1, we need n to be such that gcd(n, k) = 1 for all k from 1 to n-1.
This is true if and only if n is a prime number.

But let me also consider n = 1:
- φ(1) = 1
- n - 1 = 0
- So φ(1) ≠ 1 - 1, so n = 1 doesn't work.

Let me check small primes:
- φ(2) = 1, 2 - 1 = 1 ✓
- φ(3) = 2, 3 - 1 = 2 ✓
- φ(5) = 4, 5 - 1 = 4 ✓

So the solution should be the sum of all primes up to some limit.

But wait, let me double-check if there are any composite numbers that satisfy this condition.

Actually, let's think about this more carefully. If φ(n) = n - 1, then n must be square-free and all prime factors of n must be such that the totient formula gives n - 1.

The key insight is that φ(n) = n ∏(1 - 1/p) for all prime factors p of n.
If φ(n) = n - 1, then n ∏(1 - 1/p) = n - 1.

This is a very restrictive condition. Let me approach this systematically.

Actually, let me re-read the problem more carefully. I believe this is asking for numbers n where φ(n) = n - 1, and we want to sum all such n.

Let me implement a solution:

```kotlin
fun eulerTotient(n: Int): Int {
    var result = n
    var i = 2
    while (i * i <= n) {
        if (n % i == 0) {
            while (n % i == 0) {
                n /= i
            }
            result -= result / i
        }
        i++
    }
    if (n > 1) {
        result -= result / n
    }
    return result
}

fun isPrime(n: Int): Boolean {
    if (n < 2) return false
    if (n == 2) return true
    if (n % 2 == 0) return false
    var i = 3
    while (i * i <= n) {
        if (n % i == 0) return false
        i += 2
    }
    return true
}

fun main() {
    // Based on mathematical analysis, φ(n) = n - 1 if and only if n is prime
    // But let's verify with a reasonable upper bound
    
    val limit = 1000000
    var sum = 0
    
    for (n in 1..limit) {
        if (eulerTotient(n) == n - 1) {
            sum += n
        }
    }
    
    println("Sum: $sum")
}
```

Wait, let me reconsider. I should be more careful about what numbers satisfy φ(n) = n - 1.

Let me think mathematically:
- φ(n) = n - 1 means exactly one number from 1 to n is not coprime to n
- This means n has exactly one divisor d > 1 such that gcd(n, d) > 1
- This happens when n is prime (since only 1 is coprime to a prime p)
- But also when n = 2 (since φ(2) = 1 = 2 - 1)

Actually, let me check n = 1:
- φ(1) = 1
- 1 - 1 = 0
- So 1 doesn't work.

Let me check small values systematically:
- n = 1: φ(1) = 1, 1 - 1 = 0 → No
- n = 2: φ(2) = 1, 2 - 1 = 1 → Yes
- n = 3: φ(3) = 2, 3 - 1 = 2 → Yes
- n = 4: φ(4) = 2, 4 - 1 = 3 → No
- n = 5: φ(5) = 4, 5 - 1 = 4 → Yes
- n = 6: φ(6) = 2, 6 - 1 = 5 → No

So it seems like only primes work. But let me be more precise and actually check for any composite numbers that might work.

The mathematical fact is that φ(n) = n - 1 if and only if n is a prime number.

Let me write a more efficient solution:

```kotlin
fun eulerTotient(n: Int): Int {
    var result = n
    var i = 2
    while (i * i <= n) {
        if (n % i == 0) {
            while (n % i == 0) {
                n /= i
            }
            result -= result / i
        }
        i++
    }
    if (n > 1) {
        result -= result / n
    }
    return result
}

fun sieveOfEratosthenes(limit: Int): List<Int> {
    val isPrime = BooleanArray(limit + 1) { true }
    isPrime[0] = isPrime[1] = false
    
    for (i in 2..kotlin.math.sqrt(limit.toDouble()).toInt()) {
        if (isPrime[i]) {
            for (j in i * i..limit step i) {
                isPrime[j] = false
            }
        }
    }
    
    return (2..limit).filter { isPrime[it] }
}

fun main() {
    // Since φ(n) = n - 1 iff n is prime, we sum all primes up to a reasonable limit
    val limit = 1000000
    
    // Find all primes up to limit
    val primes = sieveOfEratosthenes(limit)
    
    val sum = primes.sum()
    println("Sum of all n such that φ(n) = n - 1: $sum")
}
```

But let me also verify by checking a few more values with direct calculation:

```kotlin
fun eulerTotient(n: Int): Int {
    var result = n
    var i = 2
    while (i * i <= n) {
        if (n % i == 0) {
            while (n % i == 0) {
                n /= i
            }
            result -= result / i
        }
        i++
    }
    if (n > 1) {
        result -= result / n
    }
    return result
}

fun main() {
    // Check for values where φ(n) = n - 1
    val limit = 1000000
    var sum = 0L
    
    for (n in 1..limit) {
        if (eulerTotient(n) == n - 1) {
            sum += n
            // println("n = $n satisfies φ(n) = n - 1")
        }
    }
    
    println("Sum: $sum")
}
```

Actually, let me be more systematic and realize that the mathematical property is that φ(n) = n - 1 if and only if n is prime (except n = 1). Let me write the final clean solution:

```kotlin
fun sieveOfEratosthenes(limit: Int): List<Int> {
    val isPrime = BooleanArray(limit + 1) { true }
    isPrime[0] = isPrime[1] = false
    
    for (i in 2..kotlin.math.sqrt(limit.toDouble()).toInt()) {
        if (isPrime[i]) {
            for (j in i * i..limit step i) {
                isPrime[j] = false
            }
        }
    }
    
    return (2..limit).filter { isPrime[it] }
}

fun main() {
    // φ(n) = n - 1 if and only if n is prime
    // So we need to sum all primes up to the given limit
    val limit = 1000000
    val primes = sieveOfEratosthenes(limit)
    val sum = primes.toLongArray().sum()
    
    println("Sum of all n such that φ(n) = n - 1: $sum")
}
```

However, looking at this more carefully, I think I should consider what the actual problem asks for. The problem might be asking for a specific range or have a different interpretation.

Let me just provide the mathematical solution:

# Euler Problem 948 Solution

The problem asks for the sum of all numbers n such that φ(n) = n - 1, where φ is Euler's totient function.

**Mathematical Analysis:**
- φ(n) = n - 1 means that exactly one number from 1 to n is not coprime to n
- This is true if and only if n is a prime number
- For a prime p, φ(p) = p - 1

**Solution:**
The sum is the sum of all prime numbers up to the specified limit.

```kotlin
fun sieveOfEratosthenes(limit: Int): List<Int> {
    val isPrime = BooleanArray(limit + 1) { true }
    isPrime[0] = isPrime[1] = false
    
    for (i in 2..kotlin.math.sqrt(limit.toDouble()).toInt()) {
        if (isPrime[i]) {
            for (j in i * i..limit step i) {
                isPrime[j] = false
            }
        }
    }
    
    return (2..limit).filter { isPrime[it] }
}

fun main() {
    val limit = 1000000  // Adjust as needed for the specific problem
    val primes = sieveOfEratosthenes(limit)
    val sum = primes.toLongArray().sum()
    
    println("Sum: $sum")
}
```

**Answer:** The sum of all numbers n such that φ(n) = n - 1 is the sum of all prime numbers up to the specified limit.

