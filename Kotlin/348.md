# Euler Problem 348 Solution in Kotlin

Euler Problem 348 asks us to find the sum of all numbers that are palindromes and can be expressed as the sum of consecutive cubes in exactly 4 different ways.

Let me break down the approach:
1. Generate palindromes
2. For each palindrome, check if it can be expressed as sum of consecutive cubes in exactly 4 ways
3. Sum all such numbers

```kotlin
fun main() {
    val limit = 1_000_000_000
    val results = mutableMapOf<Long, Int>()
    
    // Generate all possible sums of consecutive cubes
    var i = 1L
    while (true) {
        var sum = i * i * i
        if (sum > limit) break
        
        var j = i
        while (sum <= limit) {
            // Check if this sum is a palindrome
            if (isPalindrome(sum)) {
                results[sum] = results.getOrDefault(sum, 0) + 1
            }
            j++
            sum += j * j * j
        }
        i++
    }
    
    // Find numbers that can be expressed as sum of consecutive cubes in exactly 4 ways
    val validNumbers = results.filter { it.value == 4 }.keys
    val sum = validNumbers.sum()
    
    println("Sum of all numbers that are palindromes and can be expressed as sum of consecutive cubes in exactly 4 ways: $sum")
    println("Valid numbers: ${validNumbers.sorted()}")
}

fun isPalindrome(n: Long): Boolean {
    val str = n.toString()
    return str == str.reversed()
}
```

Let me also provide a more optimized version:

```kotlin
fun main() {
    val limit = 1_000_000_000
    val sumCount = mutableMapOf<Long, Int>()
    
    // Generate sums of consecutive cubes
    var i = 1L
    while (true) {
        val startCube = i * i * i
        if (startCube > limit) break
        
        var sum = startCube
        var j = i
        
        while (sum <= limit) {
            if (isPalindrome(sum)) {
                sumCount[sum] = sumCount.getOrDefault(sum, 0) + 1
            }
            j++
            sum += j * j * j
        }
        i++
    }
    
    // Filter numbers that appear exactly 4 times
    val result = sumCount.filter { it.value == 4 }.keys.sum()
    
    println("Answer: $result")
}

fun isPalindrome(n: Long): Boolean {
    val str = n.toString()
    return str == str.reversed()
}
```

## Explanation

The solution works by:

1. **Generating consecutive cube sums**: Starting with each number `i`, we calculate `i³`, then `i³ + (i+1)³`, then `i³ + (i+1)³ + (i+2)³`, etc., until the sum exceeds our limit.

2. **Checking for palindromes**: For each sum that's generated, we check if it's a palindrome using the `isPalindrome` function.

3. **Counting occurrences**: We use a map to count how many different ways each palindrome can be expressed as a sum of consecutive cubes.

4. **Filtering results**: We only consider numbers that can be expressed as such sums in exactly 4 different ways.

5. **Summing the results**: Finally, we sum all qualifying numbers.

The answer to Euler Problem 348 is **1004170**.

