# Euler Problem 431 Solution in Kotlin

## Problem Statement
Let $S(n)$ be the sum of all positive integers $k$ such that $k$ divides $n$ and $\gcd(k, n/k) = 1$. Find $S(10^{12})$.

## Analysis
This problem asks for the sum of all divisors $k$ of $n$ such that $\gcd(k, n/k) = 1$. 

Key insights:
1. If $k$ divides $n$, then $n/k$ also divides $n$
2. The condition $\gcd(k, n/k) = 1$ means $k$ and $n/k$ are coprime
3. This is equivalent to saying that $k$ and $n/k$ share no common prime factors
4. For $k$ and $n/k$ to be coprime, each prime factor of $n$ must entirely belong to either $k$ or $n/k$, but not both

## Mathematical Approach
If $n = p_1^{a_1} \cdot p_2^{a_2} \cdot \ldots \cdot p_m^{a_m}$, then:
- Each divisor $k$ can be written as $k = p_1^{b_1} \cdot p_2^{b_2} \cdot \ldots \cdot p_m^{b_m}$ where $0 \leq b_i \leq a_i$
- For $\gcd(k, n/k) = 1$, we need $\gcd(p_1^{b_1} \cdot \ldots \cdot p_m^{b_m}, p_1^{a_1-b_1} \cdot \ldots \cdot p_m^{a_m-b_m}) = 1$
- This means for each prime $p_i$, either $b_i = 0$ or $b_i = a_i$ (but not both)

Therefore, each prime factor can either go entirely to $k$ or entirely to $n/k$, giving us $2^m$ possible combinations, but we must exclude the case where all $b_i = 0$ (which would make $k = 1$).

Wait, let me reconsider this more carefully.

Actually, for $\gcd(k, n/k) = 1$, we want $k$ and $n/k$ to be coprime. This happens when each prime factor of $n$ belongs entirely to either $k$ or $n/k$, but not both.

For each prime $p_i^{a_i}$ in the factorization of $n$:
- We can choose to include all $a_i$ copies in $k$, or 
- We can choose to include all $a_i$ copies in $n/k$

This gives us $2^m$ choices, but we need to be more careful about what this means for the actual sum.

## Better Approach
Let's think of it this way:
- For each prime power $p^a$ in $n$, we can decide whether all copies of $p$ go to $k$ or to $n/k$
- If all copies of $p$ go to $k$, then $k$ is divisible by $p^a$
- If all copies of $p$ go to $n/k$, then $k$ is not divisible by $p$

So we're essentially looking for divisors $k$ such that $k$ and $n/k$ are coprime.

This is equivalent to finding divisors $k$ of $n$ such that $\gcd(k, n) = \gcd(k, n/k) \cdot \gcd(k, n/k) = 1$.

Actually, let's approach it differently using the fact that if $\gcd(k, n/k) = 1$, then $k \cdot (n/k) = n$ and $\gcd(k, n/k) = 1$, which means $k$ and $n/k$ are coprime divisors of $n$.

## Key Insight
If $k$ is a divisor of $n$ and $\gcd(k, n/k) = 1$, then $k$ and $n/k$ form a coprime pair of divisors whose product is $n$.

This is equivalent to: $k = d$ where $d$ is a divisor of $n$ such that $\gcd(d, n/d) = 1$.

## Solution Approach
For $n = p_1^{a_1} \cdot p_2^{a_2} \cdot \ldots \cdot p_m^{a_m}$:
1. Each such divisor $k$ corresponds to choosing for each prime whether it belongs entirely to $k$ or entirely to $n/k$
2. This gives us $2^m$ possible choices
3. We want to sum over all valid $k$ values

But we can think of it more directly:
- If $n = p_1^{a_1} \cdot p_2^{a_2} \cdot \ldots \cdot p_m^{a_m}$, then the divisors $k$ such that $\gcd(k, n/k) = 1$ are those where each prime factor of $n$ goes entirely to either $k$ or $n/k$
- This means $k$ is of the form $p_1^{b_1} \cdot p_2^{b_2} \cdot \ldots \cdot p_m^{b_m}$ where each $b_i \in \{0, a_i\}$

Therefore, the sum is the sum over all combinations where each $b_i \in \{0, a_i\}$:
$$S(n) = \sum_{b_1 \in \{0,a_1\}} \sum_{b_2 \in \{0,a_2\}} \ldots \sum_{b_m \in \{0,a_m\}} p_1^{b_1} \cdot p_2^{b_2} \cdot \ldots \cdot p_m^{b_m}$$

This equals:
$$S(n) = \prod_{i=1}^{m} (1 + p_i^{a_i})$$

## Kotlin Implementation

```kotlin
fun solve(): Long {
    val n = 1000000000000L // 10^12
    
    // Factorize n = 2^a * 3^b * 5^c * 7^d * ... 
    val factors = primeFactorize(n)
    
    var result = 1L
    for ((prime, exponent) in factors) {
        result = result * (1 + prime.toLong().pow(exponent)) % 1000000007L
    }
    
    return result
}

fun primeFactorize(n: Long): Map<Long, Int> {
    val factors = mutableMapOf<Long, Int>()
    var num = n
    var d = 2L
    
    while (d * d <= num) {
        while (num % d == 0L) {
            factors[d] = factors.getOrDefault(d, 0) + 1
            num /= d
        }
        d++
    }
    
    if (num > 1) {
        factors[num] = factors.getOrDefault(num, 0) + 1
    }
    
    return factors
}

fun Long.pow(exponent: Int): Long {
    var base = this
    var exp = exponent
    var result = 1L
    
    while (exp > 0) {
        if (exp % 2 == 1) {
            result *= base
        }
        base *= base
        exp /= 2
    }
    
    return result
}

fun main() {
    println(solve())
}
```

Wait, let me reconsider the mathematical approach more carefully.

Looking at the problem again, I think there's a more direct approach. The key insight is that for each prime factor $p^a$ of $n$, we can either:
1. Include all $a$ copies in $k$, or
2. Include all $a$ copies in $n/k$

But the condition $\gcd(k, n/k) = 1$ means that each prime factor of $n$ must entirely belong to either $k$ or $n/k$, but not both.

So for each prime factor $p^a$, we have two choices: include all $a$ copies in $k$ or include all $a$ copies in $n/k$. 

Therefore, $S(n) = \prod_{p^a \| n} (p^a + 1)$ where $p^a \| n$ means $p^a$ is the highest power of $p$ dividing $n$.

```kotlin
fun solve(): Long {
    val n = 1000000000000L // 10^12
    
    val factors = primeFactorize(n)
    
    var result = 1L
    for ((prime, exponent) in factors) {
        val primePower = prime.toLong().pow(exponent)
        result = (result * (primePower + 1)) % 1000000007L
    }
    
    return result
}

fun primeFactorize(n: Long): Map<Long, Int> {
    val factors = mutableMapOf<Long, Int>()
    var num = n
    var d = 2L
    
    while (d * d <= num) {
        while (num % d == 0L) {
            factors[d] = factors.getOrDefault(d, 0) + 1
            num /= d
        }
        d++
    }
    
    if (num > 1) {
        factors[num] = factors.getOrDefault(num, 0) + 1
    }
    
    return factors
}

fun Long.pow(exponent: Int): Long {
    if (exponent == 0) return 1L
    if (exponent == 1) return this
    
    var base = this
    var exp = exponent
    var result = 1L
    
    while (exp > 0) {
        if (exp % 2 == 1) {
            result *= base
        }
        base *= base
        exp /= 2
    }
    
    return result
}

fun main() {
    println(solve())
}
```

