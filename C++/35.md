# Euler Problem 35 Solution in C++

## Problem Statement
The number, 197, is called a circular prime because all rotations of the digits: 197, 971, and 719, are themselves prime.

How many circular primes are there below one million?

## Solution

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>

using namespace std;

// Function to check if a number is prime
bool isPrime(int n) {
    if (n < 2) return false;
    if (n == 2) return true;
    if (n % 2 == 0) return false;
    
    for (int i = 3; i <= sqrt(n); i += 2) {
        if (n % i == 0) return false;
    }
    return true;
}

// Function to get all rotations of a number
vector<int> getRotations(int n) {
    vector<int> rotations;
    string s = to_string(n);
    int len = s.length();
    
    for (int i = 0; i < len; i++) {
        // Rotate left by i positions
        string rotated = s.substr(i) + s.substr(0, i);
        rotations.push_back(stoi(rotated));
    }
    
    return rotations;
}

// Function to check if a number is circular prime
bool isCircularPrime(int n) {
    vector<int> rotations = getRotations(n);
    
    for (int rotation : rotations) {
        if (!isPrime(rotation)) {
            return false;
        }
    }
    
    return true;
}

int main() {
    int count = 0;
    int limit = 1000000;
    
    // Check all numbers below one million
    for (int i = 2; i < limit; i++) {
        if (isCircularPrime(i)) {
            count++;
        }
    }
    
    cout << "Number of circular primes below one million: " << count << endl;
    
    return 0;
}
```

## Explanation

The solution works as follows:

1. **isPrime function**: Efficiently checks if a number is prime by testing divisibility up to √n, skipping even numbers after 2.

2. **getRotations function**: Takes a number and generates all possible rotations of its digits. For example, for 197, it generates [197, 971, 719].

3. **isCircularPrime function**: Checks if all rotations of a number are prime. If any rotation is not prime, the number is not circular prime.

4. **Main function**: Iterates through all numbers from 2 to 999,999 and counts how many are circular primes.

## Key Optimizations

- The prime checking function only tests odd divisors up to √n
- We only check numbers from 2 to 999,999 (since 1 is not prime)
- The rotation generation uses string manipulation for simplicity

## Result

The answer is **55** circular primes below one million.

