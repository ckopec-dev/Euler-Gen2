# Euler Problem 810 Solution in Perl

I'll solve Euler Problem 810, which asks for the number of ways to tile a 3×n rectangle with 2×1 dominoes.

## Problem Understanding

We need to find the number of ways to completely tile a 3×n rectangle using 2×1 dominoes (which can be placed either horizontally or vertically).

## Approach

This is a classic dynamic programming problem. I'll use the transfer matrix method or direct DP approach.

Let's define:
- `f(n)` = number of ways to tile a 3×n rectangle
- We'll consider the states of the rightmost column and build up the solution

## Solution

```perl
#!/usr/bin/perl
use strict;
use warnings;

sub solve_euler_810 {
    my $n = shift;
    
    # Base cases
    if ($n == 0) { return 1; }
    if ($n == 1) { return 1; }
    if ($n == 2) { return 3; }
    
    # For larger n, use dynamic programming
    # We'll use the transfer matrix approach or direct DP
    
    # Let's use direct DP approach with states
    # State representation: different ways to fill the last column
    
    # For 3×n rectangle, we can use the recurrence relation
    # This is a known sequence where f(n) = f(n-1) + 5*f(n-2) + f(n-3) - f(n-4)
    # But let's implement a more direct approach
    
    # Using the known recurrence relation for 3×n tiling with dominoes:
    # f(n) = f(n-1) + 5*f(n-2) + f(n-3) - f(n-4) for n >= 4
    # with f(0)=1, f(1)=1, f(2)=3, f(3)=11
    
    my @dp = (0, 1, 3, 11);
    
    for my $i (4..$n) {
        $dp[$i] = $dp[$i-1] + 5*$dp[$i-2] + $dp[$i-3] - $dp[$i-4];
    }
    
    return $dp[$n];
}

# Alternative implementation using matrix exponentiation for efficiency
sub solve_euler_810_matrix {
    my $n = shift;
    
    # For very large n, we could use matrix exponentiation
    # But for reasonable values, the recurrence works fine
    
    if ($n == 0) { return 1; }
    if ($n == 1) { return 1; }
    if ($n == 2) { return 3; }
    if ($n == 3) { return 11; }
    
    my $a = 1;  # f(0)
    my $b = 1;  # f(1)
    my $c = 3;  # f(2)
    my $d = 11; # f(3)
    
    for my $i (4..$n) {
        my $next = $d + 5*$c + $b - $a;
        $a = $b;
        $b = $c;
        $c = $d;
        $d = $next;
    }
    
    return $d;
}

# Main execution
my $result = solve_euler_810_matrix(10);
print "Answer for n=10: $result\n";

# Let's compute a few more values to verify
print "Values for small n:\n";
for my $i (0..8) {
    my $val = solve_euler_810_matrix($i);
    print "f($i) = $val\n";
}

# For the actual problem, we need the answer for n=1000
my $answer = solve_euler_810_matrix(1000);
print "\nAnswer for n=1000: $answer\n";

# If we need the answer modulo some number (common in Euler problems)
# For example, if we need answer mod 10^9 + 7:
my $MOD = 1000000007;
my $answer_mod = $answer % $MOD;
print "Answer mod 10^9 + 7: $answer_mod\n";
```

## Explanation

The solution uses the recurrence relation for tiling a 3×n rectangle with 2×1 dominoes:

- f(0) = 1 (one way to tile empty rectangle)
- f(1) = 1 (one vertical domino)
- f(2) = 3 (three ways to tile 3×2 rectangle)
- f(3) = 11 (eleven ways to tile 3×3 rectangle)
- For n ≥ 4: f(n) = f(n-1) + 5×f(n-2) + f(n-3) - f(n-4)

This recurrence comes from analyzing how the tiling can be extended from smaller rectangles, considering all possible ways to fill the rightmost columns.

## Key Insights

1. **Dynamic Programming**: The problem has optimal substructure and overlapping subproblems
2. **Recurrence Relation**: The specific recurrence for 3×n tiling with dominoes
3. **Efficiency**: Using iterative approach instead of recursion to avoid stack overflow
4. **Modular Arithmetic**: For very large numbers, we can take modulo to keep results manageable

The time complexity is O(n) and space complexity is O(1) for the iterative approach.

