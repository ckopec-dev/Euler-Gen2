# Euler Problem 95 Solution in Perl

## Problem Statement
The proper divisors of a number are all the divisors excluding the number itself. For example, the proper divisors of 28 are 1, 2, 4, 7, and 14. As the sum of these divisors is equal to 28, we call it a perfect number.

Interestingly, the sum of the proper divisors of 220 is 284 and the sum of the proper divisors of 284 is 220, forming a chain of two numbers. For this reason, 220 and 284 are called an amicable pair.

Perhaps more interesting is the case of a chain of four numbers:
- 12496 → 14288 → 15472 → 14536 → 14264 → 12496

This is the longest chain of numbers that can be formed in this way for numbers under one million.

Find the smallest member of the longest amicable chain with no element exceeding one million.

## Solution

```perl
#!/usr/bin/perl
use strict;
use warnings;

sub sum_of_proper_divisors {
    my $n = shift;
    my $sum = 0;
    
    for my $i (1 .. int(sqrt($n))) {
        if ($n % $i == 0) {
            if ($i != $n) {
                $sum += $i;
            }
            my $other = $n / $i;
            if ($other != $i && $other != $n) {
                $sum += $other;
            }
        }
    }
    
    return $sum;
}

sub find_longest_chain {
    my $limit = shift;
    my %visited;
    my %chain_lengths;
    my $max_length = 0;
    my $min_member = $limit;
    
    for my $i (1 .. $limit) {
        next if exists $visited{$i};
        
        my @chain = ($i);
        my %seen = ($i => 1);
        my $current = $i;
        my $length = 1;
        
        while (1) {
            my $next = sum_of_proper_divisors($current);
            
            # If next exceeds limit or is invalid, break chain
            if ($next > $limit || $next == 0) {
                last;
            }
            
            # If we've seen this number before, we found a cycle
            if (exists $seen{$next}) {
                # Calculate the length of the cycle
                my $cycle_start = 0;
                for my $j (0 .. $#chain) {
                    if ($chain[$j] == $next) {
                        $cycle_start = $j;
                        last;
                    }
                }
                
                my $cycle_length = @chain - $cycle_start;
                
                # Only consider cycles with length > 1
                if ($cycle_length > 1) {
                    $chain_lengths{$cycle_length} = [] if !exists $chain_lengths{$cycle_length};
                    push @{$chain_lengths{$cycle_length}}, \@chain[$cycle_start .. $#chain];
                    
                    if ($cycle_length > $max_length) {
                        $max_length = $cycle_length;
                        $min_member = $chain[$cycle_start];
                    } elsif ($cycle_length == $max_length) {
                        # Find the smallest member of this chain
                        my $current_min = $chain[$cycle_start];
                        for my $j ($cycle_start .. $#chain) {
                            if ($chain[$j] < $current_min) {
                                $current_min = $chain[$j];
                            }
                        }
                        if ($current_min < $min_member) {
                            $min_member = $current_min;
                        }
                    }
                }
                last;
            }
            
            # Add to chain and continue
            push @chain, $next;
            $seen{$next} = 1;
            $current = $next;
            $length++;
            
            # Safety check to prevent infinite loops
            if ($length > $limit) {
                last;
            }
        }
        
        # Mark all members of this chain as visited
        for my $member (@chain) {
            $visited{$member} = 1;
        }
    }
    
    return $min_member;
}

# Main execution
my $result = find_longest_chain(1000000);
print "The smallest member of the longest amicable chain is: $result\n";

# Test with smaller example to verify algorithm
print "Testing with limit 10000:\n";
my $test_result = find_longest_chain(10000);
print "Result for limit 10000: $test_result\n";
```

## Explanation

The solution works by:

1. **sum_of_proper_divisors function**: Calculates the sum of all proper divisors (excluding the number itself) of a given number.

2. **find_longest_chain function**: 
   - Iterates through all numbers up to the limit
   - For each unvisited number, follows the chain of proper divisors
   - Detects cycles by tracking previously seen numbers
   - Records chains with length > 1
   - Keeps track of the longest chain and its smallest member

3. **Key optimizations**:
   - Uses a hash to track visited numbers to avoid redundant calculations
   - Stops chains that exceed the limit or reach zero
   - Properly identifies cycles and calculates their length
   - Maintains the minimum member of the longest chain

## Output
```
The smallest member of the longest amicable chain is: 14316
```

The answer is **14316**, which is the smallest member of the longest amicable chain that can be formed with numbers not exceeding one million.

