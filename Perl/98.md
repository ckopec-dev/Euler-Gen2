# Euler Problem 98 Solution in Perl

## Problem Statement
By replacing each of the letters in the word CARE with 1, 2, 9, and 6 respectively, we form a square number: 1296 = 36Â². We shall call this a square anagram word pair and consider CARE and RACE as an anagram pair.

Given a list of words, find the largest square number formed by any member of such a square anagram word pair.

## Solution

```perl
#!/usr/bin/perl
use strict;
use warnings;
use List::Util qw(max);

# Read dictionary file
my @words = read_words("words.txt");

# Find all anagram groups
my %anagram_groups = group_anagrams(@words);

# Find the largest square from anagram pairs
my $max_square = 0;

foreach my $group (values %anagram_groups) {
    next if @$group < 2;  # Need at least 2 words to form a pair
    
    # Get all pairs from the group
    for my $i (0..$#{$group}-1) {
        for my $j ($i+1..$#{$group}) {
            my $word1 = $group->[$i];
            my $word2 = $group->[$j];
            
            # Find the largest square number for this pair
            my $largest = find_largest_square($word1, $word2);
            $max_square = max($max_square, $largest);
        }
    }
}

print "Largest square: $max_square\n";

# Helper functions
sub read_words {
    my $filename = shift;
    open my $fh, '<', $filename or die "Cannot open $filename: $!";
    my $content = do { local $/; <$fh> };
    close $fh;
    
    # Split by commas and remove quotes
    my @words = split /,/, $content;
    @words = map { s/"//g; $_ } @words;
    return @words;
}

sub group_anagrams {
    my %groups;
    foreach my $word (@_) {
        my $sorted = join('', sort split //, $word);
        push @{$groups{$sorted}}, $word;
    }
    return %groups;
}

sub find_largest_square {
    my ($word1, $word2) = @_;
    
    my $len = length($word1);
    
    # Generate all square numbers of the right length
    my @squares = generate_squares($len);
    
    my $max_square = 0;
    
    # Try all possible digit mappings
    foreach my $square (@squares) {
        my $mapping = word_to_digits($word1, $square);
        if ($mapping && is_valid_mapping($mapping, $word1, $word2)) {
            my $result = word_to_square($word2, $mapping);
            $max_square = max($max_square, $result);
        }
    }
    
    return $max_square;
}

sub generate_squares {
    my $len = shift;
    
    my @squares;
    my $start = int(sqrt(10**($len-1))) + 1;
    my $end = int(sqrt(10**$len));
    
    for my $i ($start..$end) {
        my $square = $i * $i;
        if (length($square) == $len) {
            push @squares, $square;
        }
    }
    
    return @squares;
}

sub word_to_digits {
    my ($word, $number) = @_;
    
    my %mapping;
    my @digits = split //, $number;
    my @letters = split //, $word;
    
    for my $i (0..$#letters) {
        my $letter = $letters[$i];
        my $digit = $digits[$i];
        
        if (exists $mapping{$letter}) {
            return undef if $mapping{$letter} != $digit;
        } else {
            $mapping{$letter} = $digit;
        }
    }
    
    # Check if any digit is mapped to multiple letters (invalid)
    my %reverse_mapping = reverse %mapping;
    return undef if keys %mapping != keys %reverse_mapping;
    
    return \%mapping;
}

sub is_valid_mapping {
    my ($mapping, $word1, $word2) = @_;
    
    # Check if the mapping works for both words
    my @letters1 = split //, $word1;
    my @letters2 = split //, $word2;
    
    # Verify that mapping is consistent
    my %used_digits;
    foreach my $letter (@letters1) {
        if (exists $mapping->{$letter}) {
            return 0 if exists $used_digits{$mapping->{$letter}};
            $used_digits{$mapping->{$letter}} = 1;
        }
    }
    
    return 1;
}

sub word_to_square {
    my ($word, $mapping) = @_;
    
    my $result = "";
    foreach my $letter (split //, $word) {
        $result .= $mapping->{$letter};
    }
    
    return int($result);
}
```

## Explanation

This solution works by:

1. **Reading the dictionary file** containing all the words
2. **Grouping anagrams together** by sorting the letters in each word
3. **For each anagram group** with at least 2 words:
   - Generate all square numbers of the appropriate length
   - Try mapping letters to digits for the first word
   - Check if this mapping is valid for the second word
   - Calculate the resulting square number
4. **Return the maximum square** found

## Key Features

- **Anagram grouping**: Uses letter sorting to identify anagram pairs
- **Digit mapping validation**: Ensures each letter maps to exactly one digit and vice versa
- **Square generation**: Efficiently generates only square numbers of the required length
- **Comprehensive checking**: Validates all constraints for valid anagram square pairs

The solution handles the complexity of ensuring that letter-to-digit mappings are consistent across both words in an anagram pair, while also ensuring that no two letters map to the same digit.

