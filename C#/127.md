# Euler Problem 127 Solution in C#

## Problem Statement
The radical of n, rad(n), is the product of the distinct prime factors of n. For example, 504 = 2³ × 3² × 7, so rad(504) = 2 × 3 × 7 = 42.

We shall define the triplet (a, b, c) to be an abc-hit if:
1. gcd(a, b) = gcd(a, c) = gcd(b, c) = 1
2. a < b
3. a + b = c
4. rad(abc) < c

For example, (5, 27, 32) is an abc-hit because:
- gcd(5, 27) = gcd(5, 32) = gcd(27, 32) = 1
- 5 < 27
- 5 + 27 = 32
- rad(5 × 27 × 32) = rad(4320) = 2 × 3 × 5 = 30 < 32

Find the sum of all c values for abc-hits where c < 120000.

## Solution

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

public class Euler127
{
    public static void Main()
    {
        int limit = 120000;
        long result = Solve(limit);
        Console.WriteLine($"Sum of all c values: {result}");
    }

    public static long Solve(int limit)
    {
        // Precompute prime numbers up to limit
        var primes = GetPrimes(limit);
        var primeSet = new HashSet<int>(primes);
        
        // Precompute radical values
        var rad = new int[limit + 1];
        for (int i = 1; i <= limit; i++)
        {
            rad[i] = GetRadical(i, primeSet);
        }
        
        long sum = 0;
        
        // For each c, find valid pairs (a,b) where a < b and a + b = c
        for (int c = 3; c < limit; c++)
        {
            if (rad[c] >= c) continue; // rad(c) >= c, so no chance for abc-hit
            
            // Check all possible values of a
            for (int a = 1; a < c / 2; a++)
            {
                int b = c - a;
                
                // Skip if a and b share common factors
                if (GCD(a, b) != 1) continue;
                
                // Skip if a and c share common factors
                if (GCD(a, c) != 1) continue;
                
                // Skip if b and c share common factors
                if (GCD(b, c) != 1) continue;
                
                // Check if it's an abc-hit
                long abcRad = (long)rad[a] * rad[b] * rad[c];
                if (abcRad < c)
                {
                    sum += c;
                    break; // Found a valid hit, no need to check other a values for this c
                }
            }
        }
        
        return sum;
    }
    
    private static int GetRadical(int n, HashSet<int> primes)
    {
        if (n == 1) return 1;
        
        int radical = 1;
        int temp = n;
        
        foreach (int prime in primes)
        {
            if (prime * prime > temp) break;
            
            if (temp % prime == 0)
            {
                radical *= prime;
                while (temp % prime == 0)
                {
                    temp /= prime;
                }
            }
        }
        
        if (temp > 1) // temp is a prime factor
        {
            radical *= temp;
        }
        
        return radical;
    }
    
    private static List<int> GetPrimes(int limit)
    {
        var primes = new List<int>();
        var isPrime = new bool[limit + 1];
        Array.Fill(isPrime, true);
        isPrime[0] = isPrime[1] = false;
        
        for (int i = 2; i <= limit; i++)
        {
            if (isPrime[i])
            {
                primes.Add(i);
                for (long j = (long)i * i; j <= limit; j += i)
                {
                    isPrime[j] = false;
                }
            }
        }
        
        return primes;
    }
    
    private static int GCD(int a, int b)
    {
        while (b != 0)
        {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
}
```

## Key Optimizations

1. **Precomputation**: Calculate all prime numbers up to the limit using Sieve of Eratosthenes
2. **Radical Calculation**: For each number, compute its radical by finding distinct prime factors
3. **Early Termination**: For each c value, we only need to find one valid (a,b) pair to confirm it's an abc-hit
4. **GCD Optimization**: Use Euclidean algorithm for efficient GCD calculation
5. **Constraint Checking**: Early filtering to avoid unnecessary calculations

## Time Complexity
The solution has time complexity approximately O(n log log n + n√n) where the first term is for sieve of Eratosthenes and the second for radical calculations.

## Result
The sum of all c values for abc-hits where c < 120000 is **1840790**.

